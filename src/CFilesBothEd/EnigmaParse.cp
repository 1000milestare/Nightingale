/****************************************************************************	FILE:	EnigmaParse.c																		**	PROJ:	Nightingale, new for v3.0														**	DESC:	Routines for reading Enigma Transportable Format files created		**			by Finale 3.0 - 3.5. Written by John Gibson.								*/***************************************************************************//*											NOTICE * * THIS FILE IS PART OF THE NIGHTINGALEª PROGRAM AND IS CONFIDENTIAL PROP- * ERTY OF ADVANCED MUSIC NOTATION SYSTEMS, INC.  IT IS CONSIDERED A TRADE * SECRET AND IS NOT TO BE DIVULGED OR USED BY PARTIES WHO HAVE NOT RECEIVED * WRITTEN AUTHORIZATION FROM THE OWNER. * * Copyright © 1996-97 by Advanced Music Notation Systems, Inc. All Rights Reserved. */#include "Nightingale_Prefix.pch"#include "Nightingale.appl.h"#ifndef LIGHT_VERSION#define SUPPORT_V35/* ??This module repeatedly uses sscanf. Unfortunately, according to the ISO Cstandard, the behavior of sscanf in certain situations is "undefined", i.e., itmight do anything including crash. It would be best to avoid sscanf completely. *//* ---------------------------------------------------------------------------------- *//* Local prototypes */static Boolean PreProcessETF(FILE *f);static Boolean ProcessETF(FILE *f);static Boolean PostProcessETF(void);static Boolean ParseCE(Boolean init);static Boolean ParseeE(FILE *f);static Boolean ParseFN(void);static Boolean ParseFR(void);static Boolean ParseFS(void);static Boolean ParseGF(Boolean init);static Boolean ParseGS(Boolean init);static Boolean ParseHT(void);static Boolean ParseIA(void);static Boolean ParseIN(short code, FILE *f);static Boolean ParseIP(void);#ifdef SUPPORT_V35static Boolean ParseIS(FILE *f);#elsestatic Boolean ParseIS(void);#endifstatic Boolean ParseIU(Boolean init);static Boolean ParseLL(void);static Boolean ParseMS(void);static Boolean ParseNS(short code);static Boolean ParsePL(void);static Boolean ParsePO(void);static Boolean ParsePP(void);static Boolean ParsePS(void);static Boolean ParseTN(Boolean init);#ifdef SUPPORT_V35static Boolean ParseTP(Boolean init, FILE *f);#elsestatic Boolean ParseTP(Boolean init);#endifstatic Boolean HexStringToLong(char *str, long *val);static Boolean Extract1Val(char *str, long *val);static Boolean Extract2Val(char *str, long *val1, long *val2);static Boolean ExtractString(char linebuf[], char string[]);static void ListScore(void);static void ListObjects(void);static void ReportParseFailure(char *);static Boolean SupportedEnigmaVersion(FILE *f);/* Functions that call the Macintosh Toolbox */static Boolean ParseTextBlocks(void);static Boolean ParseLyrics(FILE *f);static short GetETFFile(Str255 macfName, short *vRefNum);static Boolean AllocETFMemory(void);static void DisposTmpMemory(void);/* ---------------------------------------------------------------------------------- *//* Globals */ETF				gETF;PTMPGFREC		gpTmpGFRecs;unsigned short	gNumStaves,						/* number of staff records in ETF file (including unused staves) */					gNumStavesUsed,				/* number of staff records used in ETF file */					gNumFrames,					gNumGFRecs,					gNumMeas,					gNumEntries,					gNumNotes,					gNumTuplets,					gNumPages,					gNumSystems,					gNumOptimizedStaves,					gNumClefs,					gNumConnects,					gNumTextBlocks,					gNumLyrics;/* Static globals */#define MAX_FRAMES   64000L#define LINELEN	128		/* Aside from lyrics, the longest line we've seen is 61 chars. */static char		gInBuf[LINELEN];static long		gLineCount = 0L;static short	gFirstEmptyNote;#ifdef SUPPORT_V35static float	gETFVersion;#endif/* indices into gETFcodes array...must match order! */static enum {	eE=0, TN, TP, FR, GF, MS, IU, IS, IA, IN, in, NS, ns, PL, IP, IM, ED, CE, CD, CH, /* 0     1   2   3   4   5   6   7   8   9   10  11  12  13  14  15  16  17  18  19 */	FN, FS, LL, PS, PO, PP, HT, GS, TEXT, LYRICS,/* 20  21  22  23  24  25  26  27  28    29 */	NUM_CODES} eCodeIndices;/* NB: It's most efficient to put the codes that will usually have more lines in thefile earlier in the gETFcodes array (e.g. ^eE). */static char *gETFcodes[NUM_CODES] = {	"^eE",		/* entry pool */	"^TN",		/* other tuplet info */	"^TP",		/* tuplet */	"^FR",		/* frame contents */	"^GF",		/* staff, measure, frame correlation */	"^MS",		/* measure definition */	"^IU",		/* from Staff Usage List dlog (invoked by STAFF TOOL) */	"^IS",		/* staff attributes (view w/ STAFF ATTRIBUTES TOOL) */	"^IA",		/* more instrument stuff, e.g.:numstafflines, fontname&size, transpose */	"^IN",		/* long instrument names */	"^in",		/* abbreviated instrument names */	"^NS",		/* long instrument name attributes (position, font, size, etc) */	"^ns",		/* abbreviated instrument name attributes */	"^PL",		/* some kind of staff info */	"^IP",		/* number of staves in system */	"^IM",		/* articulation marking */	"^ED",		/* staff expression marking */	"^CE",		/* clef change record (usually for mid-measure clef changes) */	"^CD",		/* cross staff note record:						^CD(0,1) 1 2 0 0 0 means entry 1 was on staff 1, now on staff 2 */	"^CH",		/* chord symbol */	"^FN",		/* font name record (assigns internal id's to font names) */	"^FS",		/* system break info */	"^LL",		/* layer info */	"^PS",		/* page size info */	"^PO",		/* page margin info */	"^PP",		/* page percent of normal size */	"^HT",		/* text of a "Title" (i.e., header or footer) */	"^GS",		/* info about staff connects (bracket, curlybrace, etc.) */	"^text",		/* text entered with the Text Block tool (CAUTION: ParseTextBlocks assumes that a line with just this text has no text blocks.) */	"^lyrics"	/* lyric text (CAUTION: ParseLyrics assumes that a line with just this text has no lyrics.) */};/* ---------------------------------------------------------------------------------- *//* High level functions (ParseETFFile, PreProcessETF, ProcessETF, PostProcessETF). *//* ----------------------------------------------------------------- ParseETFFile -- */Boolean ParseETFFile(Str255 ETFfileName){	short			vRefNum;	Boolean		ok, listObjects = TRUE;	FILE			*f;	if (!GetETFFile(ETFfileName, &vRefNum)) return FALSE;	f = OpenInputFile(ETFfileName, vRefNum);	if (f==NULL) return FALSE;		#if CNTLKEYFORLISTOBJECTS	if (!ControlKeyDown())		listObjects = FALSE;#endif	WaitCursor();#if SHOW_PROGRESSWINDOW	if (!listObjects)		ProgressMsg(CONVERTETF_PMSTR, "");#endif	ok = PreProcessETF(f);	if (!ok) {		CloseInputFile(f);		goto err;	}		ok = ProcessETF(f);	CloseInputFile(f);													/* done with input file */	if (!ok) goto err;	ok = PostProcessETF();	if (!ok) goto err;#if LISTSCORE	ListScore();#endif#if LISTOBJECTS	if (listObjects)		ListObjects();#endif	return TRUE;err:#if SHOW_PROGRESSWINDOW	ProgressMsg(0, "");										/* Remove progress window, if it hasn't already been removed. */#endif	DisposETFMemory();	return FALSE;}/* ---------------------------------------------------------------- PreProcessETF -- *//* Count the number of objects of various kinds in the ETF file, and allocate memory for them. Also initialize any parsers that require that. Then rewind thefile position pointer. Returns TRUE if file makes sense to it and memory allocated;otherwise returns FALSE. */ static Boolean PreProcessETF(FILE *f){	short		i, ans;	short		xtraLines, highestEntry=0, highestFrame=0;	char		codeStr[32];	Boolean	ok, breakOut;	long		along;		gNumStaves = gNumStavesUsed = gNumFrames = gNumGFRecs = gNumMeas = gNumEntries = \	gNumNotes = gNumTuplets = gNumPages = gNumSystems = gNumClefs = \	gNumConnects = gNumOptimizedStaves = gNumTextBlocks = gNumLyrics = 0;	gFirstEmptyNote = 1;		/* Init these parse functions. */	ParseCE(TRUE);	ParseGF(TRUE);	ParseGS(TRUE);	ParseIU(TRUE);	ParseTN(TRUE);#ifdef SUPPORT_V35	ParseTP(TRUE, f);#else	ParseTP(TRUE);#endif		if (!SupportedEnigmaVersion(f)) return FALSE;		/* Count the objects we're interested in. */	while (ReadLine(gInBuf, LINELEN, f)) {		gLineCount++;		for (i = 0, breakOut = FALSE; i<NUM_CODES; i++) {			if (strstr(gInBuf, gETFcodes[i])) {				switch (i) {					case eE:						/* Count entries and dependent notes. Some ETF files have missing entry indices						 * (e.g., ^eE(22)..., ^eE(24)... without ^eE(23)...), so set gNumEntries to the						 * maximum index value encountered. Since I use these indices as indices into the						 * array of entries I build, it's important that I allocate space for all the						 * index values I find, even if I leave some array slots empty.						 */						ans = sscanf(gInBuf, "%s%*d%*d%*d%*d%*s%*d%d", codeStr, &xtraLines);						if (ans<2) goto broken;						if (!Extract1Val(codeStr, &along)) goto broken;						if (along>highestEntry)							gNumEntries = highestEntry = along;						gNumNotes += xtraLines;						if (xtraLines==0) gNumNotes++;		/* most rests have xtraLines==0, but I want space for them in note array */						breakOut = TRUE;	break;					case FR:						/* ETF files whose deleted notes have been removed by Data Check may have missing						 * frame indices. Instead of counting the existing frame records, set gNumFrames to 						 * the maximum index value encountered. Since I use these indices as indices into the						 * array of frames I build, it's important that I allocate space for all the						 * index values I find, even if I leave some array slots empty. Obviously, this						 * approach can lead to very inefficient use of memory, so perhaps later it should						 * be changed to omit empty slots and store the frame link in the frame record.						 * ??WARNING: This problem, which I observed first for entries and notes, could be						 * even more general. It's possible that it's just plain foolish to organize my						 * temporary data structure in this manner!!						 */						ans = sscanf(gInBuf, "%s%*d%*d%*d%*d", codeStr);						if (ans<1) goto broken;						if (!Extract1Val(codeStr, &along)) goto broken;                  if (along>MAX_FRAMES) continue;						if (along>highestFrame)							gNumFrames = highestFrame = along;						breakOut = TRUE;	break;					case GF:						gNumGFRecs++;						breakOut = TRUE;	break;					case MS:						gNumMeas++;						breakOut = TRUE;	break;					case FS:						gNumSystems++;						breakOut = TRUE;	break;					case TP:						gNumTuplets++;						breakOut = TRUE;	break;					case CE:						gNumClefs++;						breakOut = TRUE;	break;					case IS:						gNumStaves++;						breakOut = TRUE;	break;					case IU:						ans = sscanf(gInBuf, "%s%*d%*d%*d%*d%*d%*d", codeStr);						if (ans<1) goto broken;						if (!Extract1Val(codeStr, &along)) goto broken;#ifdef SUPPORT_V35						if ((INT16)along>0) {							if (gETFVersion>=3.5)								gNumOptimizedStaves += 1;							else								gNumOptimizedStaves += 2; 								/* 2 records per ^IU line */						}#else						if ((INT16)along>0)							gNumOptimizedStaves += 2; 										/* 2 records per ^IU line */#endif						breakOut = TRUE;	break;					case PS:						gNumPages++;						breakOut = TRUE;	break;					case GS:						gNumConnects++;						breakOut = TRUE;	break;				}				if (breakOut) break;			}		}	}#ifdef SUPPORT_V35	if (gETFVersion>=3.5) {		gNumStaves /= 3;				/* Three ^IS records per staff in v. 3.5 */		gNumTuplets /= 3;				/* Three ^TP records per tuplet in v. 3.5 */	}#endif#if SHORTDEBUGsay("PreProcessETF: %d staves, %d pages, %d systems, %d measures, %d frames, %d layers, \							%d entries, %d notes, %d tuplets, %d clefs, %d connects\n\n",			gNumStaves, gNumPages, gNumSystems, gNumMeas, gNumFrames, gNumLayers, \			gNumEntries, gNumNotes, gNumTuplets, gNumClefs, gNumConnects);say("\nETF file contained %ld lines\n\n", gLineCount);#endif		ok = AllocETFMemory();	if (!ok) return FALSE;		gLineCount = 0L;	rewind(f);		return TRUE;broken:	MayErrMsg("PreProcessETF: error scanning this file.");	return FALSE;}/* ------------------------------------------------------------------ ProcessETF -- */static Boolean ProcessETF(FILE *f){	short		i, checkcount = 1;	Boolean	ok, breakOut;		while (ReadLine(gInBuf, LINELEN, f)) {		gLineCount++;#ifdef NOTYET		if (--checkcount==0) { 			CheckEvent();										/* yield time to background tasks */			if (gAbortTranslate) return FALSE;			checkcount = BG_CHK_FREQ;		}#endif		ok = TRUE;		breakOut = FALSE;		for (i = 0; i<NUM_CODES; i++) {			if (strstr(gInBuf, gETFcodes[i])) {				switch (i) {					case CE:			ok = ParseCE(FALSE);			breakOut = TRUE; break;					case eE:			ok = ParseeE(f);				breakOut = TRUE; break;					case FR:			ok = ParseFR();				breakOut = TRUE; break;					case FS:			ok = ParseFS();				breakOut = TRUE; break;					case GF:			ok = ParseGF(FALSE);			breakOut = TRUE; break;					case IA:			ok = ParseIA();				breakOut = TRUE; break;					case in:					case IN:			ok = ParseIN(i, f);			breakOut = TRUE; break;					case IP:			ok = ParseIP();				breakOut = TRUE; break;#ifdef SUPPORT_V35					case IS:			ok = ParseIS(f);				breakOut = TRUE; break;#else					case IS:			ok = ParseIS();				breakOut = TRUE; break;#endif					case IU:			ok = ParseIU(FALSE);			breakOut = TRUE; break;					case LL:			ok = ParseLL();				breakOut = TRUE; break;					case MS:			ok = ParseMS();				breakOut = TRUE; break;					case ns:					case NS:			ok = ParseNS(i);				breakOut = TRUE; break;					case PL:			ok = ParsePL();				breakOut = TRUE; break;					case PO:			ok = ParsePO();				breakOut = TRUE; break;					case PP:			ok = ParsePP();				breakOut = TRUE; break;					case PS:			ok = ParsePS();				breakOut = TRUE; break;					case TN:			ok = ParseTN(FALSE);			breakOut = TRUE; break;#ifdef SUPPORT_V35					case TP:			ok = ParseTP(FALSE, f);		breakOut = TRUE; break;#else					case TP:			ok = ParseTP(FALSE);			breakOut = TRUE; break;#endif					case GS:			ok = ParseGS(FALSE);			breakOut = TRUE; break;					case TEXT:		ok = ParseTextBlocks();		breakOut = TRUE; break;					case LYRICS:	ok = ParseLyrics(f);			breakOut = TRUE; break;				}				if (!ok) return FALSE;									/* This may be too drastic in some cases. */				if (breakOut) break;			}		}	}	return TRUE;}/* --------------------------------------------------------------- PostProcessETF -- *//* Fill in various fields that cannot be computed before we read all the ETF data.Returns TRUE if ok, FALSE if error. */static Boolean PostProcessETF(void){	short		i, j, thisL, lastL, clefGroup, frame, layerInfoID;	Boolean	gotMatch;		/* Fill in the rest of the frame information, using the temporary array of ^GF records.	 * (See discussion below, at pragma mark "*Frame Organization".)	 */		for (i = 0; i<gNumGFRecs; i++) {		layerInfoID = gpTmpGFRecs[i].layerInfoID;		frame = gpTmpGFRecs[i].frame;		/* If frame is greater than zero, it means that there is a frame for layer 1. (I.e., layer 1		 * has notes on the staff in the measure for this tmp ^GF record.) If so, fill in staffID,		 * meas number, etc. fields. If not, this tmp ^GF record gives such information for other		 * layers.		 */		if (frame) {														/* Fill in fields for layer 1's frame (if there is one). */			if (frame>gNumFrames)				MayErrMsg("PostProcessETF: tmpGFrec %d has frame out of range (%d).", i, frame);			else {				gETF.pFrames[frame].layerNum = 1;				gETF.pFrames[frame].staffID = gpTmpGFRecs[i].staffID;				gETF.pFrames[frame].meas = gpTmpGFRecs[i].meas;				gETF.pFrames[frame].startClef = gpTmpGFRecs[i].startClef;				gETF.pFrames[frame].hasClefChange = gpTmpGFRecs[i].hasClefChange;			}		}		/* If this tmp ^GF record has a non-zero layerInfoID, it means that the measure and staff to which		 * it refers have notes in layer(s) other than layer 1. Fill in fields for the relevant frames.		 */		if (layerInfoID)			for (j = 1; j<=gNumFrames; j++) {						/* Find the relevant frames (as many as 3) */				if (j==frame) continue;									/* Already done this one above. */				if (gETF.pFrames[j].layerInfoID==layerInfoID) {					gETF.pFrames[j].staffID = gpTmpGFRecs[i].staffID;					gETF.pFrames[j].meas = gpTmpGFRecs[i].meas;					gETF.pFrames[j].startClef = gpTmpGFRecs[i].startClef;					gETF.pFrames[j].hasClefChange = gpTmpGFRecs[i].hasClefChange;				}			}	}			/* Fill in the frameL field of each entry. */	for (i = 1; i<=gNumFrames; i++) {		if (gETF.pFrames[i].staffID==0) continue;						/* empty frame node */		lastL = gETF.pFrames[i].lastL;		for (thisL = gETF.pFrames[i].firstL; thisL; thisL = gETF.pEntries[thisL].nextL) {			if (gETF.pEntries[thisL].validNode==FALSE) {				MayErrMsg("PostProcessETF: Frame %d contains entry %d, but that entry is invalid.", i, thisL);				continue;			}			gETF.pEntries[thisL].frameL = i;			if (thisL==lastL) break;										/* Don't go to next frame! */		}	}		/* Fill in the frameL field of each clef. */	// ??Note that no subsequent code actually relies on this field. Guess we don't need it!	for (i = 1; i<=gNumFrames; i++) {		if (gETF.pFrames[i].staffID==0) continue;						/* empty frame node */		if (gETF.pFrames[i].hasClefChange) {			clefGroup = gETF.pFrames[i].startClef;			for (j = 1; j<=gNumClefs; j++)				if (gETF.pClefs[j].clefGroup==clefGroup)					gETF.pClefs[j].frameL = i;		}	}		/* For every entry that claims to start a tuplet, make sure there is actually a tuplet	 * record for it. If not, clear the entry's startTuplet flag. (Sometimes Finale entries	 * have this inconsistency. Finale does not seem to be bothered by it.)	 */	for (i = 1; i<=gNumEntries; i++) {		if (gETF.pEntries[i].validNode && gETF.pEntries[i].startTuplet) {			for (j = 1, gotMatch = FALSE; j<=gNumTuplets; j++) {				if (gETF.pTuplets[j].entryL==i) {					gotMatch = TRUE;					break;				}			}			if (!gotMatch)				gETF.pEntries[i].startTuplet = FALSE;		}	}		DisposTmpMemory();	return TRUE;}/* ---------------------------------------------------------------------------------- *//* Functions for parsing individual ETF codes */#pragma mark *Frame Organization/* Putting an Enigma note into the correct voice and measure is far more difficult than it oughtto be. To do so, we must coordinate the information contained in four different Enigma codes:^FR, ^GF, ^LL and ^eE. Here is a summary of the purpose of each code:	^eE gives the note/chord/rest data ("entry" in Enigma-speak). It has a separate line			for each note in a chord.	^FR gives the first and last entry contained in one "frame".			(A "frame" is a single non-empty measure on one staff in one layer. If a measure			on one staff has more than one layer, it will have more than one frame.)	^GF gives the measure number and staff ID for each frame. If a frame is in a layer 			other than layer 1, the ^GF record points to a ^LL record that gives more info.	^LL gives the frame described by a ^GF record when that frame is not in layer 1.When a frame is in layer 1, the coordination of all this information is relativelystraightforward. Here's an example:	^FR(2) 9 12 0 0							[frame 2 starts w/ entry 9 and ends w/ entry 12]	^GF(3,11) 2 0 0 0 512					[frame 2 is on staff 3 in measure 11]	^eE(9) 0 10 4096 0 $C0200800 0 1		[entry 9, the 1st entry in frame 2 (next entry: 10)]			 32 $C0010000 						[note data for entry 9]Things get really messy when the frame is not in layer 1. In this case, the ^GF recordpoints to an ^LL record, which gives the frame. The awkwardness is twofold:	1) The ^GF record gives the staff ID and measure number we want, but it doesn't		give the frame; the associated ^LL record gives the frame we want, but it doesn't		give the staff and measure. So we have to coordinate the two kinds of record.	2) If a measure on a staff contains several layers, just one ^GF record describes this.		It contains a layerInfoID (our term) that associates it with a maximum of 4 ^LL		records, each giving the frame for a single layer. (But layer 1, the default layer,		is described fully by the ^GF record, so its ^LL record is a dummy. Ugh.) Each of		these ^LL records has the same layerInfoID.Because the ^FR, ^GF and ^LL codes are in different parts of the Enigma file, we place all the^GF records in a temporary array. Later (in PostProcessETF) we put together the pieces of thepuzzle and come up with one array (gETF.pFrames) of frame (ETF_FRAME) records. Each recordcontains a staff ID, a measure number, a layer number and links to its first and last entries.(That's the way Coda should've designed it in the first place...)This scheme is further complicated by the possibility that records describing deleted framesare still in the ETF file. It seems that the ^FR records are fully up-to-date. That is, whena user deletes the contents of a frame in Finale, its ^FR record goes away. However, if theframe had a ^LL record, that may stay in the file. We have to know which records to ignore.Fortunately, it also seems that ^GF records are kept up-to-date, so it's only vestigial ^LLrecords that we have to worry about. *//* ---------------------------------------------------------------------- ParseFR -- *//* In Finale a "frame" is one measure on one staff in one layer; it containsat least one note or rest that is not a whole-measure rest. (So a measurewith just a whole rest in it isn't a frame.) The information about framesis given by three Enigma codes: ^FR, ^GF and ^LL. The code that this functionparses, ^FR, associates a frame with links of the first and last entries (notes/rests/chords) contained in the frame.An example line:  ^FR(2) 9 12 0 0                       |  |  | | |__ ?                      |  |  | |____ measure width                      |  |  |______ last entry                      |  |_________ first entry                      |____________ frame (index into our gETF.pFrames array)*/ static Boolean ParseFR(void){	char		codeStr[32];	short		ans, 				frame, firstEvt, lastEvt, measWid, n4;	long		along;	ans = sscanf(gInBuf, "%s%d%d%d%d", codeStr, &firstEvt, &lastEvt, &measWid, &n4);	if (ans<5) goto broken;		if (!Extract1Val(codeStr, &along)) goto broken;   /* Ignore very large frame numbers; not sure what they're for anyway! */        if (along>MAX_FRAMES) return TRUE;	frame = along;	#if FULLDEBUGsay("%s\n", gInBuf);say("\tFR: frame=%d, firstEvt=%d, lastEvt=%d, measWid=%d\n\n", frame, firstEvt, lastEvt, measWid);#endif	gETF.pFrames[frame].firstL = firstEvt;	gETF.pFrames[frame].lastL = lastEvt;	gETF.pFrames[frame].measWid = measWid;		return TRUE;broken:	ReportParseFailure("ParseFR");	return FALSE;}/* ---------------------------------------------------------------------- ParseGF -- *//* Parse a line that coordinates information about staves, measures, layers and frames.An example line:  ^GF(1,2) 2 0 0 1 512                      | |  | | | |  |__ flags                      | |  | | | |_____ if non-zero, gives layerInfoID (see ^LL)                      | |  | | |_______ ?                      | |  | |_________ startClef                      | |  |___________ frame in layer 1                        | |______________ measure number                      |________________ staff ID (NB: not nec. in score order)  Frames for layers 2-4, if any, given by ^LL records with same layerInfoID.	If frame given by ^GF record is zero, but layerInfoID is not zero, it means that	this measure on this staff has no notes in layer 1 but does have notes in layers	2, 3 and/or 4.For reasons explained above (at pragma mark "*Frame Organization"), we store the ^GF recordsin a temporary array (gpTmpGFRecs), not in the ETF data structure. */ static Boolean ParseGF(Boolean init){	char		codeStr[32];	short		ans, staffID, meas, frame, startClef, n3, layerInfoID, flags;	long		long1, long2;	static unsigned short counter;		if (init) {		counter = 0;				/* gpTmpGFRecs is a zero-based array */		return TRUE;	}		if (counter>=gNumGFRecs) goto broken;	ans = sscanf(gInBuf, "%s%d%d%d%d%d%d", codeStr, &frame, &startClef, &n3, &layerInfoID, &flags);	if (ans<6) goto broken;		if (!Extract2Val(codeStr, &long1, &long2)) goto broken;	staffID = long1;	meas = long2;	#if FULLDEBUGsay("%s\n", gInBuf);say("\tGF: staffID=%d, meas=%d, frame=%d, startClef=%d\n\n", staffID, meas, frame, startClef);#endif		gpTmpGFRecs[counter].staffID = staffID;	gpTmpGFRecs[counter].meas = meas;	gpTmpGFRecs[counter].frame = frame;	gpTmpGFRecs[counter].layerInfoID = layerInfoID;	gpTmpGFRecs[counter].startClef = startClef;	gpTmpGFRecs[counter].hasClefChange = (flags & 1024)? TRUE : FALSE;	counter++;	return TRUE;broken:	ReportParseFailure("ParseGF");	return FALSE;}/* ---------------------------------------------------------------------- ParseLL -- *//* Parse a line defining a layer.An example line:  ^LL(1,1) 2 0 0 1 512                      | |  | | | |  |__ ? [flags from layer dlog?]                      | |  | | | |_____ ? [often same as layerInfoID, but not always?]                      | |  | | |_______ ?                      | |  | |_________ ?                      | |  |___________ frame                      | |______________ layer number (zero based: 0-3)                      |________________ layerInfo ID (referenced by ^GF)See discussion above (at pragma mark "*Frame Organization") for how we coordinate thisinformation with that given by other codes. */ static Boolean ParseLL(void){	char		codeStr[32];	short		ans, layerInfoID, layerNum, frame, n2, n3, n4, flags;	long		long1, long2;	ans = sscanf(gInBuf, "%s%d%d%d%d%d%d", codeStr, &frame, &n2, &n3, &n4, &flags);	if (ans<6) goto broken;		if (!Extract2Val(codeStr, &long1, &long2)) goto broken;	layerInfoID = long1;	layerNum = long2;	#if FULLDEBUGsay("%s\n", gInBuf);say("\tLL: layerInfoID=%d, layern=%d, frame=%d, flags=%d\n\n", layerInfoID, layerNum+1, frame, flags);#endif		if (frame>0 && frame<=gNumFrames) {		gETF.pFrames[frame].layerNum = layerNum+1;		gETF.pFrames[frame].layerInfoID = layerInfoID;	}	/* Else, this ^LL record means one of two things:	 *   1) it's a dummy record for layer 1, which ^GF describes fully, or	 *   2) it applies to a frame that is no longer in this file. (This can	 *      happen in an extracted part, e.g. Herman Gersten's "Piccolo" file.)	 * In both cases we should just ignore the record.	 * Note that it is still possible that the frame given by this ^LL record	 * will be in our gETF.pFrames array but will have a staffID of zero,	 * meaning that it isn't valid (doesn't have a corresponding ^GF record?).	 * In this case storing the layerNum and layerInfoID into this record, as	 * we do in the preceding block of code, will do no harm. If the frame's	 * staffID is zero, all other parts of the code ignore the frame.	 */		return TRUE;broken:	ReportParseFailure("ParseLL");	return FALSE;}/* ---------------------------------------------------------------------- ParseCE -- *//* Parse a line describing a clef change, usually a "Moveable Mid-measure Clef."An example line:  ^CE(1) 1 1536 0 75 0 0                       |  |   |  |  | | |__ ?                      |  |   |  |  | |____ ?                      |  |   |  |  |______ clef size (% of normal)                      |  |   |  |_________ vert. dist from staff top (EVPU's), which doesn't affect pitch though                      |  |   |____________   start time of clef change, from beginning of measure in EDU's                      |  |________________ clef type (0=treble, 1=alto, etc.)                      |___________________ clefGroup  When this is zero, it's a beginning-of-measure clef.When a frame hasClefChange, its ^GF record points to a clef group, a collectionof clef changes occuring in that frame, ordered by start time (in EDU's). Therecan be any number of clef changes in one frame.Note that an index into my array of clefs (gETF.pClefs) does not correspond toany field in the ETF file. */static Boolean ParseCE(Boolean init){	char			codeStr[32];	short			ans, clefGroup, startTime, vOffset, sizePct, clefType, n5, n6;	long			along;	static unsigned short counter;		if (init) {		counter = 1;		return TRUE;	}		if (counter>gNumClefs) goto broken;		ans = sscanf(gInBuf, "%s%d%d%d%d%d%d", codeStr, &clefType, &startTime, &vOffset, &sizePct, &n5, &n6);	if (ans<7) goto broken;		if (!Extract1Val(codeStr, &along)) goto broken;	clefGroup = along;#if FULLDEBUG	say("%s\n\n", gInBuf);#endif	gETF.pClefs[counter].clefGroup = clefGroup;	gETF.pClefs[counter].frameL = 0;									/* can't know this yet; assign in PostProcessETF */	gETF.pClefs[counter].startTime = startTime;	gETF.pClefs[counter].vOffset = vOffset;	gETF.pClefs[counter].sizePct = sizePct;	gETF.pClefs[counter].clefType = clefType;	counter++;	return TRUE;broken:	ReportParseFailure("ParseCE");	return FALSE;}/* ---------------------------------------------------------------------- ParseTN -- *//* Parse a line giving tuplet attributes set in tuplet dialog.NB: The ^TN record is obsolete in v. 3.5.An example line:  ^TN(0,9) 24 0 0 0 1                      | |  |  | | | |__ flags                        | |  |  | | |____ right offset                      | |  |  | |______ middle offset                      | |  |  |________ left offset                      | |  |___________ number offset                      | |______________ link num of 1st note of tuplet                      |________________ [always zero?]  Flag bits are: 15 14 13 12 11 10  9  8  7  6  5  4  3  2  1  0     if set,...  |  |  |  |  |  |  |  |  |  |  |  |  |  |  |____ (bits 0-1) 0:nothing, 1:number only,   |  |  |  |  |  |  |  |  |  |  |  |  |  |         2:number w/ slur, 3:number w/ bracket  |  |  |  |  |  |  |  |  |  |  |  |  |  |_______ ?  |  |  |  |  |  |  |  |  |  |  |  |  |__________ ?  |  |  |  |  |  |  |  |  |  |  |  |_____________ ?  |  |  |  |  |  |  |  |  |  |  |________________ ?  |  |  |  |  |  |  |  |  |  |___________________ ?  |  |  |  |  |  |  |  |  |______________________ ?  |  |  |  |  |  |  |  |_________________________ ignore format offset  |  |  |  |  |  |  |____________________________ break slur/bracket  |  |  |  |  |  |_______________________________ use ratio for number (i.e. ':' in Ng)  |  |  |  |  |__________________________________ use bottom note  |  |  |  |_____________________________________ ?  |  |  |________________________________________ ?  |  |___________________________________________ ?  |______________________________________________ ?*/ static Boolean ParseTN(Boolean init){	static unsigned short counter;	char				codeStr[32];	short				ans, entryL, numOffset, leftOffset, midOffset, rightOffset, flags;	long				long1, long2;	if (init) {		counter = 1;		return TRUE;	}		if (counter>gNumTuplets) goto broken;	ans = sscanf(gInBuf, "%s%d%d%d%d%d", codeStr, &numOffset, &leftOffset, &midOffset, &rightOffset, &flags);	if (ans<6) goto broken;		if (!Extract2Val(codeStr, &long1, &long2)) goto broken;	entryL = long2;	gETF.pTuplets[counter].entryL = entryL;	gETF.pTuplets[counter].format = flags & 0x03;				/* use lowest two bits (see eETFtuplets enum) */	gETF.pTuplets[counter].useRatio = (flags & ETFTUPLET_USERATIO)? TRUE : FALSE;#if FULLDEBUG	say("%s\n\n", gInBuf);#endif	counter++;	return TRUE;broken:	ReportParseFailure("ParseTN");	return FALSE;}/* ---------------------------------------------------------------------- ParseTP -- *//* Parse a line defining a tuplet.An example line:  ^TP(0,9) 3 512 2 512 2                      | |  |  |  |  |  |__ ?? 1 less than linknum of last note in tuplet? NO!!                      | |  |  |  |  |_____ denomDurUnit (in EDU's)                      | |  |  |  |________ accDenom                      | |  |  |___________ denom1 (in EDU's)                      | |  |______________ accNum                      | |_________________ link num of 1st note of tuplet                      |___________________ [always zero?]Here's how it works:A tuplet has accNum numDurUnit's in the time of accDenom denomDurUnit's.For example, the line above specifies an 8th note triplet,which has 3 8ths in the time of 2 8ths.Version 3.5 supportIn v. 3.5 there are 3 ^TP records per tuplet and no ^TN records. The ^TP recordsincorporate and extend the data from the old ^TP and ^TN records. Here is a description of the 3 ^TP records. Some terms below are taken from the TupletDefinition dialog box. (Invoke in tuplet mode by double-clicking a tuplet handle.)   ^TP(0,3) 3 512 2 512 4        | |  |  |  |  |  |__ ??       | |  |  |  |  |_____ denomDurUnit (in EDU's)       | |  |  |  |________ accDenom       | |  |  |___________ denom1 (in EDU's)       | |  |______________ accNum       | |_________________ link num of 1st note of tuplet       |___________________ [always zero?]   ^TP(0,3) 0 48 0 24 1280        | |  |  | |  |   |__ flags   [see below]       | |  |  | |  |______ Shape V offset       | |  |  | |_________ Shape H offset       | |  |  |___________ Number V offset       | |  |______________ Number H offset       | |_________________ link num of 1st note of tuplet       |___________________ [always zero?]   ^TP(0,3) -36 0 -36 0 0        | |   |  |  |  | |__ Slope       | |   |  |  |  |____ Right Extension       | |   |  |  |_______ Right Hook       | |   |  |__________ Left Extension       | |   |_____________ Left Hook       | |_________________ link num of 1st note of tuplet       |___________________ [always zero?]   Flag bits are: 15 14 13 12 11 10  9  8  7  6  5  4  3  2  1  0  If set,...  |  |  |  |  |  |  |  |  |  |  |  |  |  |  |  |_ Number: Number (i.e., just numerator)  |  |  |  |  |  |  |  |  |  |  |  |  |  |  |____ Number: Ratio (i.e. ':' in Ng)  |  |  |  |  |  |  |  |  |  |  |  |  |  |_______ [unused]  |  |  |  |  |  |  |  |  |  |  |  |  |__________ [unused]  |  |  |  |  |  |  |  |  |  |  |  |_____________ Placement: Beam Side  |  |  |  |  |  |  |  |  |  |  |________________ [unused]  |  |  |  |  |  |  |  |  |  |___________________ [unused]  |  |  |  |  |  |  |  |  |______________________ Allow Horizontal Drag  |  |  |  |  |  |  |  |_________________________ Ignore Format Offset  |  |  |  |  |  |  |____________________________ Break Slur or Bracket  |  |  |  |  |  |_______________________________ Match Length of Hooks  |  |  |  |  |__________________________________ Use Bottom Note  |  |  |  |_____________________________________ Shape: Slur  |  |  |________________________________________ Shape: Bracket  |  |___________________________________________ [unused]  |______________________________________________ Auto Bracket NB: If bits 0 and 1 are clear, no number is displayed.     If bits 12 and 13 are clear, no shape is displayed.	  Note that the bit position of some of these flags has changed	  from v. 3.2.CAUTION: When parsing 3.5, this function changes the contents of gInBuf,since it must read three lines of text.*/#ifdef SUPPORT_V35static Boolean ParseTP(Boolean init, FILE *f)#elsestatic Boolean ParseTP(Boolean init)#endif{	static unsigned short counter;	char				codeStr[32];	short				ans, entryL, accNum, accDenom, numDurUnit, denomDurUnit;	INT16				flags;	long				long1, long2;	if (init) {		counter = 1;		return TRUE;	}		if (counter>gNumTuplets) goto broken;#ifdef SUPPORT_V35	if (gETFVersion>=3.5) {		short	numHoffset, numVoffset, shapeHoffset, shapeVoffset, n6,				leftHook, leftExtension, rightHook, rightExtension, slope, format;				ans = sscanf(gInBuf, "%s%d%d%d%d%d", codeStr, &accNum, &numDurUnit,															&accDenom, &denomDurUnit, &n6);		if (ans<6) goto broken;		if (!Extract2Val(codeStr, &long1, &long2)) goto broken;		entryL = long2;		if (!ReadLine(gInBuf, LINELEN, f)) goto broken;			/* EOF before receiving continuation line */		gLineCount++;		/* We care only about <flags> for our conversion. */		ans = sscanf(gInBuf, "%s%d%d%d%d%d", codeStr, &numHoffset, &numVoffset,															&shapeHoffset, &shapeVoffset, &flags);		if (ans<6) goto broken;		if (!Extract2Val(codeStr, &long1, &long2)) goto broken;		if (long2!=entryL) goto broken;		if (!ReadLine(gInBuf, LINELEN, f)) goto broken;			/* EOF before receiving continuation line */		gLineCount++;		/* We don't even make use of the following data in our conversion. */		ans = sscanf(gInBuf, "%s%d%d%d%d%d", codeStr, &leftHook, &leftExtension,															&rightHook, &rightExtension, &slope);		if (ans<6) goto broken;		if (!Extract2Val(codeStr, &long1, &long2)) goto broken;		if (long2!=entryL) goto broken;		gETF.pTuplets[counter].entryL = entryL;		gETF.pTuplets[counter].accNum = accNum;		gETF.pTuplets[counter].accDenom = accDenom;		gETF.pTuplets[counter].numDurUnit = numDurUnit;		gETF.pTuplets[counter].denomDurUnit = denomDurUnit;				/* NB: We're still using the eETFtuplets enum, which made sense for			v. 3.2, but is clumsy now. */		if (flags & 0x01)			format = ETFTUPLET_NUMONLY;		else			format = ETFTUPLET_NOTHING;		if (flags & 0x1000)			format = ETFTUPLET_NUMSLUR;		if (flags & 0x2000)			format = ETFTUPLET_NUMBRACKET;		gETF.pTuplets[counter].format = format;		gETF.pTuplets[counter].useRatio = (flags & 0x02)? TRUE : FALSE;	}	else {		ans = sscanf(gInBuf, "%s%d%d%d%d%d", codeStr, &accNum, &numDurUnit, &accDenom, &denomDurUnit, &flags);		if (ans<6) goto broken;				if (!Extract2Val(codeStr, &long1, &long2)) goto broken;		entryL = long2;				/* Since all ^TN lines precede the ^TP lines, all tuplets in the file			have already been stored in the tuplets array (gETF.pTuplets). The 			^TP lines should correspond to the ^TN lines (e.g., the 2nd ^TN line			gives information about the same tuplet as the 2nd ^TP line. */			if (gETF.pTuplets[counter].entryL != entryL) goto broken;	/* somehow the corresponding ^TN record doesn't have the same entryL */			gETF.pTuplets[counter].accNum = accNum;		gETF.pTuplets[counter].accDenom = accDenom;		gETF.pTuplets[counter].numDurUnit = numDurUnit;		gETF.pTuplets[counter].denomDurUnit = denomDurUnit;	}#else	ans = sscanf(gInBuf, "%s%d%d%d%d%d", codeStr, &accNum, &numDurUnit, &accDenom, &denomDurUnit, &flags);	if (ans<6) goto broken;		if (!Extract2Val(codeStr, &long1, &long2)) goto broken;	entryL = long2;		/* Since all ^TN lines precede the ^TP lines, all tuplets in the file	 * have already been stored in the tuplets array (gETF.pTuplets). The 	 * ^TP lines should correspond to the ^TN lines (e.g., the 2nd ^TN line	 * gives information about the same tuplet as the 2nd ^TP line.	 */	if (gETF.pTuplets[counter].entryL != entryL) goto broken;	/* somehow the corresponding ^TN record doesn't have the same entryL */	gETF.pTuplets[counter].accNum = accNum;	gETF.pTuplets[counter].accDenom = accDenom;	gETF.pTuplets[counter].numDurUnit = numDurUnit;	gETF.pTuplets[counter].denomDurUnit = denomDurUnit;#endif	#if FULLDEBUG	say("%s\n\n", gInBuf);#endif	counter++;	return TRUE;broken:	ReportParseFailure("ParseTP");	return FALSE;}/* ---------------------------------------------------------------------- ParseGS -- *//* Parse a line giving info about staff connects. (Consult the dialog invoked by the Bracket Tool.)(All measurements below in EVPU's.)An example line:  ^GS(2) 3 -20 0 0 0 0                      |  |  |  | | | |__ ?                      |  |  |  | | |____ ?                      |  |  |  | |______ vertical adjust (bottom of bracket)                      |  |  |  |________ vertical adjust (top of bracket)                      |  |  |___________ distance from left edge of staff                      |  |______________ connect type (See ETF_CONNECTS enum.)                      |_________________ group number (from staff object)Some things to watch out for...  1) A group may have more than one connect (unlike in Ngale).  2) A connect in the Enigma file may not be used by any group (i.e., no     staves in use have the connect's group number).  3) The staves in a group may not be adjacent. In this case they still     share a connect, but the connect is drawn separately for each chunk     of adjacent staves within the group. E.g., Create a score with 4     staves, group staves 2 & 4 (not including 3!), add bracket to this     group => 2 small brackets with identical characteristics drawn, one     next to staff 2, the other next to staff 4. */static Boolean ParseGS(Boolean init){	static unsigned short counter;	char				codeStr[32];	short				ans, group, type, xOffset, vAdjustTop, vAdjustBot, n5, n6;	long				along;	if (init) {		counter = 1;		return TRUE;	}		if (counter>gNumConnects) goto broken;	ans = sscanf(gInBuf, "%s%d%d%d%d%d%d", codeStr, &type, &xOffset, &vAdjustTop, &vAdjustBot, &n5, &n6);	if (ans<7) goto broken;		if (!Extract1Val(codeStr, &along)) goto broken;	group = along;		gETF.pConnects[counter].group = group;	gETF.pConnects[counter].type = type;	gETF.pConnects[counter].xOffset = xOffset;#ifdef NOTYET	gETF.pConnects[counter].vAdjustTop = vAdjustTop;	gETF.pConnects[counter].vAdjustBot = vAdjustBot;#endif	#if FULLDEBUG	say("%s\n\n", gInBuf);#endif	counter++;	return TRUE;broken:	ReportParseFailure("ParseGS");	return FALSE;}/* ---------------------------------------------------------------------- ParseIP -- *//* ????The ^IP code may be obsolete in Finale 3.0! */static Boolean ParseIP(void){	char		codeStr[32];	short		ans, 				numstaves, n1, n2, n3, n4, n5;		/* ??must these be longs? */	ans = sscanf(gInBuf, "%s%d%d%d%d%d%d", codeStr, &numstaves, &n1, &n2, &n3, &n4, &n5);	if (ans<7) goto broken;	#if FULLDEBUGsay("%s\n", gInBuf);say("\tIP: numstaves=%d\n\n", numstaves);#endif		return TRUE;broken:	ReportParseFailure("ParseIP");	return FALSE;}/* ---------------------------------------------------------------------- ParseIU -- *//* Parse a line giving staff vertical positions and grouping information. Note thatone ETF line gives this information about *two* staves at a time. If there are anodd number of staves in the file, the last record will have zeros for its secondstaff. As far as I know, the staves appear in the ETF file in score order (e.g.,flute first, contrabass last, etc.). So the first ^IU record will contain infofor the top two staves, the next record for the next two staves, and so on.IMPORTANT: The assignment of staffNum (==staffn in Ngale) to each staff dependson this assumption. (See discussion of the gNumStavesUsed global var below.)An example line:	^IU(0) 1 2 -80 2 0 -364		 |  | |  |  | |   |__ staff2 vertical offset (from top of system, in EVPU's)		 |  | |  |  | |______ staff2 group		 |  | |  |  |________ staff2 ID (index into our pStaves array, NOT nec. in score order!)		 |  | |  |___________ staff1 vertical offset		 |  | |______________ staff1 group		 |  |________________ staff1 ID		 |___________________ system number    This 16-bit signed int can mean one of three things (and see comments in code):  1) If zero, gives global configuration (shown in Scroll View), with no staves hidden.  2) If positive, gives the system number for the following staves. This appears when     the user has asked Finale to optimize the system (hide all empty staves), even if     no staves were actually hidden on that system. For each system affected, there will     be numStaves/2 ^IU(systemNum) records. Any staff ID that appeared in the global     configuration (systemNum==0) but is missing from this set of records has been     optimized. Note that the vertical offsets of staves below any hidden staff will     change relative to their offset in the global configuration.  3) If negative, indicates a staff that's no longer in use???     ??Acually, I have no idea what this means! I have seen numbers like 65528 (i.e, -8)       for staves that didn't seem to appear in the file. (See "tut7.etf", for example.)       One thing to investigate: Staff Sets...         ^IU(65500) gives staves visible in Staff Set 1         ^IU(65501) gives staves visible in Staff Set 2         [....]         ^IU(65507) gives staves visible in Staff Set 8       NB: Note that this range (65500-65507) does NOT include 65528, mentioned above,           so the puzzle isn't completely solved.Note that ETF files can contain records for staves that were deleted (either by theuser or by Finale itself, e.g. when deleting the conductor track in a MIDI file ithas converted). A deleted staff may still have a ^IS record, but it will not appearin any ^IU record. I want to keep these deleted staves in my temporary data structure,because I use ETF's staff ID field as an index into the pStaves array, and deletingthe unused staves would complicate that scheme. However, that means that gNumStavesis not a reliable indicator of the number of staves in the file. So I've addedanother global, gNumStavesUsed, to give the number of staves actually used inthe ETF file.Version 3.5 supportIn v. 3.5 the ^IU line describes only one staff. The fields are:	^IU(0) 1 2 0 0 -364		 |  | | | |   |___ staff vertical offset (from top of system, in EVPU's)		 |  | | | |_______ [unknown]		 |  | | |_________ [unknown]		 |  | |___________ staff group		 |  |_____________ staff ID (index into our pStaves array, NOT nec. in score order!)		 |________________ system number   [as above]*/ static Boolean ParseIU(Boolean init){	static unsigned short counter;								/* for pOptimizedStaves, not pStaves! */	char			codeStr[32];	short			ans, staff1, group1, vOffset1, staff2, group2, vOffset2;#ifdef SUPPORT_V35	short			n3, n4;	/* unknown fields */#endif	INT16			systemNum;	long			along;		if (init) {		counter = 1;		return TRUE;	}	#ifdef SUPPORT_V35	if (gETFVersion>=3.5) {		ans = sscanf(gInBuf, "%s%d%d%d%d%d", codeStr, &staff1, &group1, &n3, &n4, &vOffset1);		if (ans<6) goto broken;	}	else {		ans = sscanf(gInBuf, "%s%d%d%d%d%d%d", codeStr, &staff1, &group1, &vOffset1,																		&staff2, &group2, &vOffset2);		if (ans<7) goto broken;	}#else	ans = sscanf(gInBuf, "%s%d%d%d%d%d%d", codeStr, &staff1, &group1, &vOffset1,																	&staff2, &group2, &vOffset2);	if (ans<7) goto broken;#endif		if (!Extract1Val(codeStr, &along)) goto broken;	systemNum = along;	if (systemNum==0) {										/* 1) Global staff setup for Scroll View */		gNumStavesUsed++;		gETF.pStaves[staff1].staffNum = gNumStavesUsed;		gETF.pStaves[staff1].vOffset = vOffset1;		gETF.pStaves[staff1].group = group1;#ifdef SUPPORT_V35		if (gETFVersion<3.5 && staff2!=0) {#else		if (staff2!=0) {#endif			gNumStavesUsed++;			gETF.pStaves[staff2].staffNum = gNumStavesUsed;			gETF.pStaves[staff2].vOffset = vOffset2;			gETF.pStaves[staff2].group = group2;		}	}	else {		if (systemNum>0) {									/* 2) System is optimized */			if (counter>gNumOptimizedStaves) goto broken;						gETF.pOptimizedStaves[counter].systemNum = systemNum;			gETF.pOptimizedStaves[counter].staffID = staff1;#ifdef NOTYET			gETF.pOptimizedStaves[counter].vOffset = vOffset1;			gETF.pOptimizedStaves[counter].group = group1;#endif			counter++;#ifdef SUPPORT_V35			if (gETFVersion<3.5 && staff2!=0) {				if (counter>gNumOptimizedStaves) goto broken;				gETF.pOptimizedStaves[counter].systemNum = systemNum;				gETF.pOptimizedStaves[counter].staffID = staff2; #ifdef NOTYET				gETF.pOptimizedStaves[counter].vOffset = vOffset2;				gETF.pOptimizedStaves[counter].group = group2; #endif				counter++;			}#else /* SUPPORT_V35 */			gETF.pOptimizedStaves[counter].systemNum = systemNum;			gETF.pOptimizedStaves[counter].staffID = staff2;#ifdef NOTYET			gETF.pOptimizedStaves[counter].vOffset = vOffset2;			gETF.pOptimizedStaves[counter].group = group2;#endif			counter++;#endif /* SUPPORT_V35 */		}		else {													/* 3) Staff Set (or staff no longer in use??) */		}	}#if FULLDEBUGsay("%s\n", gInBuf);say("\tIU: sysNum=%d: staffID=%d, group=%d, vOffset=%d\n\t    staffID=%d, group=%d, vOffset=%d\n\n",					systemNum, staff1, group1, vOffset1, staff2, group2, vOffset2);#endif		return TRUE;broken:	ReportParseFailure("ParseIU");	return FALSE;}/* ---------------------------------------------------------------------- ParseIS -- *//*	Parse a line giving "staff attributes" assigned using the Staff Attributes Tool.	An example line:  ^IS(1) 0 255 4 1024 0 1024	                      |  |  |  |  |   |   |__ flags  	                      |  |  |  |  |   |______ transposition&clef...?	                      |  |  |  |  |__________ time sig denominator (in EDU's)	                      |  |  |  |_____________ time sig numerator	                      |  |  |________________ ??	                      |  |___________________ lo byte: first clef id (0=treble, 3=bass, etc.), hi byte: transp clef id??	                      |______________________ staff ID number (not necc. in score order!)	   flags bit fields: 15 14 13 12 11 10  9  8  7  6  5  4  3  2  1  0    If set,...	    (set in Staff     |  |  |  |  |  |  |  |  |  |  |  |  |  |  |  |___ ignore key sigs	    Attributes dlog)  |  |  |  |  |  |  |  |  |  |  |  |  |  |  |______ ?	                      |  |  |  |  |  |  |  |  |  |  |  |  |  |_________ ?	                      |  |  |  |  |  |  |  |  |  |  |  |  |____________ don't display clefs	                      |  |  |  |  |  |  |  |  |  |  |  |_______________ don't display timesigs	                      |  |  |  |  |  |  |  |  |  |  |__________________ don't display keysigs	                      |  |  |  |  |  |  |  |  |  |_____________________ ?	                      |  |  |  |  |  |  |  |  |________________________ ?	                      |  |  |  |  |  |  |  |___________________________ don't display staff name	                      |  |  |  |  |  |  |______________________________ don't display endings	                      |  |  |  |  |  |_________________________________ don't display measnums	                      |  |  |  |  |____________________________________ don't display expressions	                      |  |  |  |_______________________________________ break repeat bars	                      |  |  |__________________________________________ break barlines btw. staves	                      |  |_____________________________________________ individual timesig element	                      |________________________________________________ individual keysig element	NB: If time sig fields are zero, use common time (4/4). These fields set only if user	    enters an initial time sig??Version 3.5 support	There no longer seems to be a ^IA record. Its info is folded into an expanded ^IS record.	^IS has been expanded to 3 lines for each staff id, parsed as follows:		^IS(1) 0 0 0 0 6144 0  [NB: Similar to v3.2 ^IA record...]			 |  | | | |  |   |__ same as flags in old ^IA record			 |  | | | |  |______ hi byte: music font size; lo byte: font style			 |  | | | |_________ ? [probably music font id (within ETF file, not Mac font num!)]			 |  | | |___________ ?			 |  | |_____________ ?			 |  |_______________ ?			 |__________________ staff id		^IS(1) 5 0 5 0 0  0 			 |  | | | | |  |__ flags [same as 3.2 ^IS, listed above]			 |  | | | | |_____ transposition [same as 3.2 ^IS -- see <transp> in code]			 |  | | | |_______ ?			 |  | | |_________ number of staff lines			 |  | |___________ ?			 |  |_____________ lo byte: first clef id (0=treble, 3=bass, etc.), hi byte: transp clef id??			 |________________ staff id		^IS(1) -772 -772 -4 0 0 0 			 |    |    |   | | | |__ ?			 |    |    |   | | |____ ?			 |    |    |   | |______ ?			 |    |    |   |________ ? [NB: look at bit pattern of -772 -772 -4...]			 |    |    |____________ ?			 |    |_________________ ?			 |______________________ staff id	It looks like 3.5 always uses the time signature info from the ^MS record	instead of storing the initial one in the ^IS record. This is ok, since	I think my code always gets this from the ^MS record.	CAUTION: When parsing 3.5, this function changes the contents of gInBuf,	since it must read three lines of text.*/ #ifdef SUPPORT_V35static Boolean ParseIS(FILE *f)#elsestatic Boolean ParseIS(void)#endif{	char		codeStr[32], transpClef, startClef;	short		ans, staffID, clefs, n3, timeSigNum, timeSigDenom, transp, flags, keyAlter, interval;	long		along;	#ifdef SUPPORT_V35	short		staffLines, musicFontSizeStyle;		if (gETFVersion>=3.5) {		short	n1, n2, n4, n5, n6;		timeSigNum = timeSigDenom = 0;	// ??don't even use these anymore				ans = sscanf(gInBuf, "%s%d%d%d%d%d%d",							codeStr, &n1, &n2, &n3, &n4, &musicFontSizeStyle, &n6);		if (ans<7) goto broken;		if (!Extract1Val(codeStr, &along)) goto broken;		staffID = along;		if (!ReadLine(gInBuf, LINELEN, f)) goto broken;			/* EOF before receiving continuation line */		gLineCount++;		ans = sscanf(gInBuf, "%s%d%d%d%d%d%d",							codeStr, &clefs, &n2, &staffLines, &n4, &transp, &flags);		if (ans<7) goto broken;		if (!Extract1Val(codeStr, &along)) goto broken;		if (along!=staffID) goto broken;		if (!ReadLine(gInBuf, LINELEN, f)) goto broken;			/* EOF before receiving continuation line */		gLineCount++;		// We don't know what any of these fields mean yet.		ans = sscanf(gInBuf, "%s%d%d%d%d%d%d",							codeStr, &n1, &n2, &n3, &n4, &n5, &n6);		if (ans<7) goto broken;		if (!Extract1Val(codeStr, &along)) goto broken;		if (along!=staffID) goto broken;	}	else {		ans = sscanf(gInBuf, "%s%d%d%d%d%d%d",							codeStr, &clefs, &n3, &timeSigNum, &timeSigDenom, &transp, &flags);		if (ans<7) goto broken;				if (!Extract1Val(codeStr, &along)) goto broken;		staffID = along;	}#else /* SUPPORT_V35 */	ans = sscanf(gInBuf, "%s%d%d%d%d%d%d",						codeStr, &clefs, &n3, &timeSigNum, &timeSigDenom, &transp, &flags);	if (ans<7) goto broken;		if (!Extract1Val(codeStr, &along)) goto broken;	staffID = along;#endif /* SUPPORT_V35 */		/* decode clefs: hi byte is transp clef; lo byte is startClef (how do they interact??) */	startClef = (char) (clefs & 0x00FF);	transpClef = (char) ((clefs & 0xFF00) >> 8);	if (!(transp & 0x8000)) transpClef = 0;	/* ignore transpClef if high bit of transp not set */		/* decode transp integer into 3 fields: keyAlter, interval, clefAlter. (See Staff Transposition dlog.) */	keyAlter = transp & 0x003F;			/* mask off upper 10 bits, leaving low 6 bits */	interval = (transp & 0x0FC0)>>6;		/* mask off all but bits 6-11; shift all the way right */	if (keyAlter & 0x0020) keyAlter = (keyAlter & 0x001F) - 32;	/* interpret 6th bit as sign */	if (interval & 0x0020) interval = (interval & 0x001F) - 32;	#if FULLDEBUG{say("%s\n\n", gInBuf);say("\tIS: staffID=%d, startClef=%d, tuningID=%d, tsNum=%d, tsDenom=%d\n\n", 				staffID, startClef, timeSigNum, timeSigDenom);}#endif		gETF.pStaves[staffID].startClef = startClef;	gETF.pStaves[staffID].transpClef = transpClef;	gETF.pStaves[staffID].timeSigNum = timeSigNum;	gETF.pStaves[staffID].timeSigDenom = timeSigDenom;	gETF.pStaves[staffID].keyAlter = keyAlter;	gETF.pStaves[staffID].transpInterval = interval;#ifdef SUPPORT_V35	if (gETFVersion>=3.5)				/* ^IA record is obsolete in 3.5 */		gETF.pStaves[staffID].numLines = staffLines;	else {		/* If the file has any ^IA records, we will have stored their info into the data			structure by now. If the file has no ^IA records, then numLines will be zero.			Change that to a reasonable default value here (5 staff lines).		 	??What if ^IA record explicitely sets numLines to zero? */		if (gETF.pStaves[staffID].numLines==0)			gETF.pStaves[staffID].numLines = 5;	}#else	if (gETF.pStaves[staffID].numLines==0)		gETF.pStaves[staffID].numLines = 5;#endif	return TRUE;broken:	ReportParseFailure("ParseIS");	return FALSE;}/* ---------------------------------------------------------------------- ParseIA -- *//* Parse a line giving additional staff attributes. (See also ^IS.)An example line:  ^IA(1) 0 0 5 0 6144 64                      |  | | | |  |   |___ flags?  [possibility: note shapes dlog inside StfAttr dlog]                      |  | | | |  |_______ hi byte: music font size; lo byte: font style (plain=0,bold,italic,etc.)                      |  | | | |__________ music font id (within ETF file, not Mac font num! -- see ^FN)                      |  | | |____________ number of staff lines                      |  | |______________ ?                      |  |________________ ?                      |___________________ staff IDNB: Some files do not have any ^AI records. (E.g., a simple new doc.)Presumably they use default values for all of the above. */ static Boolean ParseIA(void){	char		codeStr[32];	short		ans, staffID, n1, n2, numLines, musicFontID, fontSizeAndStyle, flags;	long		along;		ans = sscanf(gInBuf, "%s%d%d%d%d%d%d",						codeStr, &n1, &n2, &numLines, &musicFontID, &fontSizeAndStyle, &flags);	if (ans<7) goto broken;		if (!Extract1Val(codeStr, &along)) goto broken;	staffID = along;		if (staffID<1 || staffID>gNumStaves)		goto broken;	gETF.pStaves[staffID].numLines = numLines;#if FULLDEBUG	say("%s\n\n", gInBuf);#endif	return TRUE;broken:	ReportParseFailure("ParseIA");	return FALSE;}/* ---------------------------------------------------------------------- ParseNS -- *//* Parse a line giving staff name attributes. If code==NS, the attributes applyto the full staff name; if code==ns, they apply to the abbreviated name.(These codes are from the eCodeIndices enum.)An example line:  ^NS(1) -72 -64 4 12 0 1                      |   |   |  |  | | |__ ?  [possibilities for these fields...                      |   |   |  |  | |____ ?  ...alignment of name, font face? ...don't think so though]                      |   |   |  |  |______ font size                      |   |   |  |_________ font id (within ETF file, not Mac font num! -- see ^FN)                      |   |   |____________ vertical offset from staff                      |   |________________ horizontal offset from staff                      |____________________ staff IDNB: These values set in sub-dialog within the Staff Attributes dialog. */static Boolean ParseNS(short /*code*/){#if FULLDEBUG	say("%s\n\n", gInBuf);#endif	return TRUE;broken:	ReportParseFailure("ParseNS");	return FALSE;}/* ---------------------------------------------------------------------- ParsePL -- */static Boolean ParsePL(void){#if FULLDEBUGsay("%s\n\n", gInBuf);#endif	return TRUE;broken:	ReportParseFailure("ParsePL");	return FALSE;}/* ---------------------------------------------------------------------- ParseFS -- *//* Parse a line giving info about system breaks in page view.        ^FS(2) 3 6 111 88 0 0            |  | |  |  |  | |__ ?            |  | |  |  |  |____ ?            |  | |  |  |_______ ?            |  | |  |__________ ? [something to do w/ width of meas in pg view]            |  | |_____________ measure number of 1st meas in *next* sys            |  |_______________ measure number of 1st meas in sys            |__________________ system number*/static Boolean ParseFS(void){	char		codeStr[32];	short		ans, sysNum, startMeas, startMeasNext, n3, n4, n5, n6;	long		along;	ans = sscanf(gInBuf, "%s%d%d%d%d%d%d", codeStr, &startMeas, &startMeasNext, &n3, &n4, &n5, &n6);	if (ans<7) goto broken;		if (!Extract1Val(codeStr, &along)) goto broken;	sysNum = along;		if (sysNum<1 || sysNum>gNumSystems) goto broken;	#if FULLDEBUGsay("\tFS: sysNum=%d, startMeas=%d\n\n", sysNum, startMeas);#endif	gETF.pSystems[sysNum].startMeas = startMeas;	gETF.pSystems[sysNum].startMeasNext = startMeasNext;	return TRUE;broken:	ReportParseFailure("ParseFS");	return FALSE;}/* ---------------------------------------------------------------------- ParsePS -- *//* Parse a line giving the page size for one page (set in the page layout dlog).This code seems to be a reliable indicator of the number of pages in a file,though be aware that Finale allows blank pages (containing no staves).        ^PS(1) 3168 2448 1 0            |   |    |   | |__ flags [2048 (bit 11 set) means page size != 100%, see ^PP record]            |   |    |   |____ sys number of 1st sys on pg, or if pg is blank:            |   |    |         0 if pg at end of file, -1 if pgs follow (?)            |   |    |________ page width (in EVPU's)            |   |_____________ page height (in EVPU's)            |_________________ page number   NB: 3168 == 11 inches, and 2448 == 8.5 inches, so this is a US Letter page.*/ static Boolean ParsePS(void){	char		codeStr[32];	short		ans, pgNum, pgHeight, pgWidth, startSys, flags;	long		along;	ans = sscanf(gInBuf, "%s%d%d%d%d", codeStr, &pgHeight, &pgWidth, &startSys, &flags);	if (ans<5) goto broken;		if (!Extract1Val(codeStr, &along)) goto broken;	pgNum = along;		if (pgNum<1 || pgNum>gNumPages) goto broken;	#if FULLDEBUGsay("\tPS: pgNum=%d, ht=%d, wid=%d, startSys=%d\n\n", pgNum, pgHeight, pgWidth, startSys);#endif	gETF.pPages[pgNum].height = pgHeight;	gETF.pPages[pgNum].width = pgWidth;	gETF.pPages[pgNum].startSys = startSys;	if (!(flags & 2048))		gETF.pPages[pgNum].sizePct = 100;	return TRUE;broken:	ReportParseFailure("ParsePS");	return FALSE;}/* ---------------------------------------------------------------------- ParsePO -- *//* Parse a line giving the page margins for one page (set in the page layout dlog.)Margin offsets are in EVPU's (qtr pts).(NB: order of margins is different than in ^SS code.)        ^PO(1) -144 216 144 -144 0 0            |    |   |   |    |  | |__ ?            |    |   |   |    |  |____ ?            |    |   |   |    |_______ right margin (rel to pg right)            |    |   |   |____________ bottom margin (rel to pg bottom)            |    |   |________________ left margin (rel to pg left)            |    |____________________ top margin (rel to pg top)            |_________________________ page number*/static Boolean ParsePO(void){	char		codeStr[32];	short		ans, pgNum, top, left, bottom, right, n5, n6;	long		along;	ans = sscanf(gInBuf, "%s%d%d%d%d%d%d", codeStr, &top, &left, &bottom, &right, &n5, &n6);	if (ans<7) goto broken;		if (!Extract1Val(codeStr, &along)) goto broken;	pgNum = along;		if (pgNum<1 || pgNum>gNumPages) goto broken;	#if FULLDEBUGsay("\tPO: page=%d, margins (t,l,b,r) = %d, %d, %d, %d\n\n", pgNum, top, left, bottom, right);#endif	gETF.pPages[pgNum].margins.top = top;	gETF.pPages[pgNum].margins.left = left;	gETF.pPages[pgNum].margins.bottom = bottom;	gETF.pPages[pgNum].margins.right = right;	return TRUE;broken:	ReportParseFailure("ParsePO");	return FALSE;}/* ---------------------------------------------------------------------- ParsePP -- *//* Parse a line giving the reduction/enlargement percentage for one page (setusing the % tool.) If a page is normal size (100%), there will be no ^PPrecord. If the page is a different size, a ^PP record will appear, and aflag is set at the end of the ^PS record for that page.        ^PP(1) 77 77 0 0 0 16384            |   |  | | | |   |____ ?            |   |  | | | |________ ?            |   |  | | |__________ ?            |   |  | |____________ ?            |   |  |______________ percent of normal size (horiz. or vert.??)            |   |_________________ percent of normal size            |_____________________ page number*/static Boolean ParsePP(void){	char		codeStr[32];	short		ans, page, sizePct1, sizePct2, n3, n4, n5, n6;	long		along;	ans = sscanf(gInBuf, "%s%d%d%d%d%d%d", codeStr, &sizePct1, &sizePct2, &n3, &n4, &n5, &n6);	if (ans<7) goto broken;		if (!Extract1Val(codeStr, &along)) goto broken;	page = along;		if (page<1 || page>gNumPages) goto broken;	#if FULLDEBUGsay("\tPP: page=%d, sizePercent=%d\n\n", page, sizePct1);#endif	gETF.pPages[page].sizePct = sizePct1;	return TRUE;broken:	ReportParseFailure("ParsePP");	return FALSE;}/* ---------------------------------------------------------------------- ParseIN -- *//* Parse a line giving a staff name. If code==IN, it's the full name; if code==in,it's the abbreviated name. (These codes are from the eCodeIndices enum.)NB: The long and abbreviated instrument names are each limited to 24 chars in Finale.One ETF line encodes at most 12 characters of text, so an instrument name spans no morethan two lines. */static Boolean ParseIN(short code, FILE *f){	short				ans, thisInst;	long				along;	fpos_t			savepos;	char				codeStr[32], thisStr[32], nextStr[32];			ans = sscanf(gInBuf, "%s", codeStr);	if (ans<1) goto broken;		if (!Extract1Val(codeStr, &along)) goto broken;	thisInst = along;		if (!ExtractString(gInBuf, thisStr)) goto broken;		/* read next line in case it's a continuation line for this instrument */	fgetpos(f, &savepos);	if (ReadLine(gInBuf, LINELEN, f)) {		gLineCount++;		along = 0L;		if (strstr(gInBuf, gETFcodes[code])) {			ans = sscanf(gInBuf, "%s", codeStr);			if (ans<1) goto broken;			if (!Extract1Val(codeStr, &along)) goto broken;		}		if (along==thisInst) {							/* this inst has continuation line */			if (!ExtractString(gInBuf, nextStr)) goto broken;			strcat(thisStr, nextStr);					/* append nextStr to thisStr */		}		else {												/* no continuation line; store what we have */					fsetpos(f, &savepos);						/* so ParseETF will read this line again */			gLineCount--;		}	}	else goto broken;#if FULLDEBUGsay("IN:	instnum=%d:   %s\t%s\n\n", thisInst, code==IN? "full:  " : "abbrev:", thisStr);say("%s\n", gInBuf);#endif	if (code==IN)		GoodStrncpy(gETF.pStaves[thisInst].fullname, thisStr, (unsigned long)25);	else		GoodStrncpy(gETF.pStaves[thisInst].abrevname, thisStr, (unsigned long)25);	return TRUE;broken:	ReportParseFailure("ParseIN");	return FALSE;}/* ---------------------------------------------------------------------- ParseMS -- */static Boolean ParseMS(void){	char		codeStr[32];	short		ans, 				meas, measWid, keySig, timeSigNum, timeSigDenom, n1, flags;	long		along;	ans = sscanf(gInBuf, "%s%d%d%d%d%d%d", codeStr, &measWid, &keySig, &timeSigNum, &timeSigDenom, &n1, &flags);	if (ans<7) goto broken;		if (!Extract1Val(codeStr, &along)) goto broken;	meas = along;	#if FULLDEBUG{say("%s\n", gInBuf);say("\tMS: meas=%d, measWid=%d, keySig=%d, tsNum=%d, tsDenom=%d\n\n", 				meas, measWid, keySig, timeSigNum, timeSigDenom);}#endif		gETF.pMeasures[meas].measWid = measWid;	gETF.pMeasures[meas].keySig = keySig;	gETF.pMeasures[meas].timeSigNum = timeSigNum;	gETF.pMeasures[meas].timeSigDenom = timeSigDenom;	return TRUE;broken:	ReportParseFailure("ParseMS");	return FALSE;}/* ---------------------------------------------------------------------- ParseHT -- *//* Parse four lines giving the text of a "Title" (i.e., header or footer).An example record:  ^HT(1) "Title"                    ^HT(1) ""                    ^HT(1) ""                    ^HT(1) ""Note that the ETF format prints strings in chunks of 12 chars (12 per line).Titles can have at most 47 chars, so ETF prints one title across 4 lines.The number enclosed in parens is an id, as usual. Not sure what references it though. */ static Boolean ParseHT(void){#if FULLDEBUG	say("%s\n\n", gInBuf);#endif	return TRUE;broken:	ReportParseFailure("ParseHT");	return FALSE;}/* ---------------------------------------------------------------------- ParseFN -- *//* Parse two or more lines associating font names with internal font id's(*not* Mac font id's!).An example record:  ^FN(15) 4096 0 0 0 0 0                    ^FN(15) "Zapf Chancer"                    ^FN(15) "y"15 is the internal font id for this font; it's name is "Zapf Chancery". Notethat the ETF format prints strings in chunks of 12 chars (12 per line). That'swhy it needs an extra line for the 'y'.??How many chars can a font name have? More than 24?The meanings of the decimal fields on the first line are unknown. */ static Boolean ParseFN(void){#if FULLDEBUG	say("%s\n\n", gInBuf);#endif	return TRUE;broken:	ReportParseFailure("ParseFN");	return FALSE;}/* ---------------------------------------------------------------------- ParseeE -- *//* For the 4-byte hex string in an entry record. The 8 hex digits are labeledfrom left to right: hex digit 1 ... hex digit 8. The comments in quotation marks give the title of the relevant checkbox in the Frames dialog (invoked by option-clicking a frame (measure on a staff) with the Simple or Speedy Note Entry tool).Use Balloon Help to discover the meaning of these switches and fields.Fields with "filler" in their name are unknown (possibly not in use). */typedef struct {/* hex digit 1 */		Boolean	legality:1;					/* "Legality" [should always be set] */							Boolean	isNote:1;					/* "Note/Rest" */							Boolean	launchesVoice2:1;			/* "V2 Launch" */							Boolean	inVoice2:1;					/* "Voice two" *//* hex digit 2 */		Boolean	filler1:1;							Boolean	hasChordSymbol:1;			/* "Chord" */							Boolean	clefChange:1;				/* "Clef Change" ("used internally by Finale; no effect on display") */							Boolean	floatRest:1;				/* "Float Rest" *//* hex digit 3 */		Boolean	isGrace:1;					/* "Grace" */							Boolean	resizeNote:1;				/* "Note Detail" */							Boolean	hasArticMark:1;			/* "Articulation" */							Boolean	hasLyricSyllable:1;		/* "Text Detail" *//* hex digit 4 */		Boolean	startTuplet:1;				/* "Tuplet" */							Boolean	v2TupParam:1;				/* "V2 Tup Para" (tweak spacing when both voices have tuplets) */							Boolean	hasPerfData:1;				/* "Perf Data" */							Boolean	filler2:1;/* hex digit 5 */		Boolean	invisible:1;				/* "Ignore" */							Boolean	beamExt:1;					/* "Beam Ext[ension]" */							Boolean	flipTie:1;					/* "Flip Tie" */							Boolean	tieDotTweaked:1;			/* "Special" *//* hex digit 6 */		Boolean	notBeamedFromPrev:1;		/* "Beam/Beat" */							Boolean	secBeamBreak:1;			/* "Sec[ondary] Beam [break]" */							Boolean	v2Beam:1;					/* "V2 Beam" */							Boolean	freezeStem:1;				/* "Freeze Stem" *//* hex digit 7 */		Boolean	stemDetail:1;				/* "Stem Detail" */							Boolean	hasCrossStem:1;			/* "Cross Up" (Balloon Help: "Note has cross-staff stem.") */							Boolean	filler3:1;							Boolean	reverseUp:1;				/* "Reverse Up" *//* hex digit 8 */		Boolean	reverseDown:1;				/* "Reverse Dn" */							Boolean	doubleStem:1;				/* "Double Stem" */							Boolean	splitStem:1;				/* "Split Stem" */							Boolean	stemFrozenUp:1;			/* "Up/Down" (When set, Balloon Help says: "This note or chord's stem, */																		/*  if it has been frozen, is frozen upward.") */} HEX1;/* For the 4-byte hex string in a note record. The comments in quotation marks givethe title of the relevant checkbox in the Frames dialog (invoked by option-clicking a frame (measure on a staff) with the Simple or Speedy Note Entry tool).Fields with "filler" in their name are unknown (possibly not in use). */typedef struct {/* hex digit 1 */		Boolean	filler1:1;					/* (always set?) */							Boolean	tiedR:1;						/* "Tie Start" */							Boolean	tiedL:1;						/* "Tie End" */							Boolean	crossStaff:1;				/* "Cross Note" *//* hex digit 2 */		Boolean	upStem2nd:1;				/* "Upstem 2nd" */							Boolean	downStem2nd:1;				/* "Downstem 2nd" */							Boolean	upStemSplit:1;				/* "Upstem Split" */							Boolean	hasAcc:1;					/* "Accidental" *//* hex digit 3 */		Boolean	parenAcc:1;					/* "(Accidental)" */							char		filler2:2;							char		noteID:5;					/* "Note ID" edit text field. This doesn't seem to be significant; it may be obsolete. *//* hex digit 4 */													/* Balloon Help says: "This number identifies the currently displayed note in the */																		/* chord," but newly entered chords never have anything other than zero in this field. */																		/* (In any case it's range is 0-31, requiring 5 bits.) *//* hex digit 5 */		char		filler3:4;/* hex digit 6 */		char		filler4:4;/* hex digit 7 */		char		filler5:4;/* hex digit 8 */		char		filler6:2;							Boolean	freezeAcc:1;				/* "Freeze Accidental" */							Boolean	filler7:1;} HEX2;/* CAUTION: This function may change the contents of gInBuf, since it might need to	read more than one line of text. */static Boolean ParseeE(FILE *f){	short	ans, thisL, prevL, nextL, dur, xOffset, hasStaffExpression, xtraLines, i, pitch;	long	along, hex1, hex2;	HEX1	*pHex1Bits;	HEX2	*pHex2Bits;	char	codeStr[32], hexstr1[32], hexstr2[32], halfline, accidental;		ans = sscanf(gInBuf, "%s%d%d%d%d%s%d%d", codeStr, &prevL, &nextL, &dur, &xOffset, hexstr1, &hasStaffExpression, &xtraLines);	if (ans<8) goto broken;		if (!Extract1Val(codeStr, &along)) goto broken;	thisL = along;	if (thisL<1 || thisL>gNumEntries) goto broken;	/* Convert hex string to long, then cast it as our HEX1 bitfield struct. */	if (!HexStringToLong(hexstr1, &hex1)) goto broken;	pHex1Bits = (HEX1 *)&hex1;		/* Assign data structure fields from bitfield struct.	 * (NB: firstL field will be filled in during loop below; frameL field will be	 * filled in later, during PostProcessETF.)	 */		gETF.pEntries[thisL].prevL = prevL;	gETF.pEntries[thisL].nextL = nextL;	gETF.pEntries[thisL].xOffset = xOffset;	gETF.pEntries[thisL].dur = dur;	gETF.pEntries[thisL].numNotes = xtraLines;	gETF.pEntries[thisL].validNode = TRUE;	gETF.pEntries[thisL].legality = pHex1Bits->legality;	gETF.pEntries[thisL].visible = !pHex1Bits->invisible;	gETF.pEntries[thisL].isGrace = pHex1Bits->isGrace;	gETF.pEntries[thisL].isRest = !pHex1Bits->isNote;	gETF.pEntries[thisL].launchesVoice2 = pHex1Bits->launchesVoice2;	gETF.pEntries[thisL].inVoice2 = pHex1Bits->inVoice2;	gETF.pEntries[thisL].startTuplet = pHex1Bits->startTuplet;	gETF.pEntries[thisL].hasPerfData = pHex1Bits->hasPerfData;	gETF.pEntries[thisL].notBeamedFromPrev = pHex1Bits->notBeamedFromPrev;	gETF.pEntries[thisL].secBeamBreak = pHex1Bits->secBeamBreak;	gETF.pEntries[thisL].hasBeamExtension = pHex1Bits->beamExt;	gETF.pEntries[thisL].hasCrossStem = pHex1Bits->hasCrossStem;	gETF.pEntries[thisL].freezeStem = pHex1Bits->freezeStem;	gETF.pEntries[thisL].stemFrozenUp = pHex1Bits->stemFrozenUp;	gETF.pEntries[thisL].flipTie = pHex1Bits->flipTie;	gETF.pEntries[thisL].hasChordSym = pHex1Bits->hasChordSymbol;	gETF.pEntries[thisL].hasArticMark = pHex1Bits->hasArticMark;#if FULLDEBUGsay("%s\n", gInBuf);say("\teE: thisL=%d, prevL=%d, nextL=%d, dur=%d, isRest=%s, notesinchord=%d\n", 			  thisL,    prevL,    nextL,    dur,    pHex1Bits->isNote? "no" : "yes", xtraLines);say("      %s, %s%s\n", 					pHex1Bits->startTuplet? "startTuplet" : "noTuplet",					pHex1Bits->notBeamedFromPrev? "notBeamedFromPrev" : "beamFromPrev",					pHex1Bits->isGrace? ", isGrace" : "");#endif	if (xtraLines==0) {									/* generate a NOTE anyway (will always be a rest) */		gETF.pEntries[thisL].numNotes = 1;		gETF.pEntries[thisL].firstNoteL = gFirstEmptyNote;		gETF.pNotes[gFirstEmptyNote].entryL = thisL;		gETF.pNotes[gFirstEmptyNote].nextL = 0;		gETF.pNotes[gFirstEmptyNote].halfline = 0;		gETF.pNotes[gFirstEmptyNote].accidental = 0;		gETF.pNotes[gFirstEmptyNote].hasAcc = FALSE;		gETF.pNotes[gFirstEmptyNote].tiedR = FALSE;		gETF.pNotes[gFirstEmptyNote].tiedL = FALSE;		gFirstEmptyNote++;	}	else {													/* generate a NOTE for each continuation line */		short lastL = 0;				gETF.pEntries[thisL].numNotes = xtraLines;		gETF.pEntries[thisL].firstNoteL = gFirstEmptyNote;				for (i = 1; i<=xtraLines; i++) {			if (!ReadLine(gInBuf, LINELEN, f)) goto broken;			/* EOF before receiving continuation line */			gLineCount++;						ans = sscanf(gInBuf, "%d%s", &pitch, hexstr2);			if (ans<2) goto broken;						halfline = (char)((pitch & 0x0FF0) >> 4);			accidental = (char)(pitch & 0x000F);						/* Convert hex string to long, then cast it as our HEX2 bitfield struct. */			if (!HexStringToLong(hexstr2, &hex2)) goto broken;			pHex2Bits = (HEX2 *)&hex2;				gETF.pNotes[gFirstEmptyNote].entryL = thisL;			if (i==xtraLines)				gETF.pNotes[gFirstEmptyNote].nextL = 0;			else				gETF.pNotes[gFirstEmptyNote].nextL = gFirstEmptyNote+1;			gETF.pNotes[gFirstEmptyNote].halfline = halfline;			gETF.pNotes[gFirstEmptyNote].accidental = accidental;			gETF.pNotes[gFirstEmptyNote].hasAcc = pHex2Bits->hasAcc;			gETF.pNotes[gFirstEmptyNote].tiedR = pHex2Bits->tiedR;			gETF.pNotes[gFirstEmptyNote].tiedL = pHex2Bits->tiedL;			gETF.pNotes[gFirstEmptyNote].crossStaff = pHex2Bits->crossStaff;			gFirstEmptyNote++;			#if FULLDEBUGsay("%s\n", gInBuf);				say("\t    halfline=%d, %s, acc=%d%s%s%s\n", halfline,					pHex2Bits->hasAcc? "hasAccidental" : "noAccidental",					accidental,					pHex2Bits->tiedL? ", tiedL" : "",					pHex2Bits->tiedR? ", tiedR" : "",					pHex2Bits->crossStaff? ", crossStaff" : "");#endif		}	}#if FULLDEBUGsay("\n");#endif		return TRUE;broken:	ReportParseFailure("ParseeE");	return FALSE;}/* ---------------------------------------------------------------------------------- *//* Parsing utilities. *//* -------------------------------------------------------------- HexStringToLong -- *//* Accepts a hex C-string having the format "$00000000" and converts it to a longint, passed back to the caller by reference as <val>. (Both vars allocated by caller.)Returns TRUE if ok, FALSE if error. */static Boolean HexStringToLong(char	*str,					/* source hex C-string */										 long	*val)					/* pass back converted value */{	char	*p;	short	ans;		p = str;	p++;																/* skip over '$' */	ans = sscanf(p, "%lx", val);								/* read numerical value in string as a long */	if (ans > 0) {		return TRUE;	} else {		*val = 0L;		return FALSE;	}}/* ------------------------------------------------------------------ Extract1Val -- *//* Extracts a numerical value from a C-string having the format "^AA(n)",where AA is a two-letter ETF code, and n is the number we want.The string is provided in <str>; the numerical value is passed back to the caller by reference as a long in <val>. (Both vars allocatedby caller.) Returns TRUE if ok, FALSE if error. */static Boolean Extract1Val(char	*str,						/* source C-string */									long	*val)						/* pass back extracted value */{	char	*p;	short	ans;		p = strchr(str, '(');										/* p will point to '(' */	if (p) {		p++;															/* advance pointer to character following '(' */		ans = sscanf(p, "%ld", val);							/* read numerical value in string as a long */		if (ans > 0)			return TRUE;	}		/* no '(' found in str or sscanf error */	*val = 0L;	return FALSE;}/* ------------------------------------------------------------------ Extract2Val -- *//* Extracts a numerical value from a C-string having the format "^AA(m,n)",where AA is a two-letter ETF code, and m and n are the numbers we want.The string is provided in <str>; the numerical values are passed back to the caller by reference as longs in <val1> and <val2>.(Both vars allocated by caller.) Returns TRUE if ok, FALSE if error. */static Boolean Extract2Val(char	*str,						/* source C-string */									long	*val1,					/* pass back first extracted value */									long	*val2)					/* pass back second extracted value */{	char	*p;	short	ans;		p = strchr(str, '(');										/* p will point to '(' */	if (p) {		p++;															/* advance pointer to character following '(' */		ans = sscanf(p, "%ld", val1);							/* read numerical value in string as a long */		if (ans <= 0) goto broken;		p = strchr(str, ',');									/* p will point to ',' */		p++;															/* advance pointer to character following ',' */		ans = sscanf(p, "%ld", val2);							/* read numerical value in string as a long */		if (ans <= 0) goto broken;		return TRUE;	}	broken:	/* no '(' found in str or sscanf error */	*val1 = 0L;	*val2 = 0L;	return FALSE;}/* ---------------------------------------------------------------- ExtractString -- *//* Extracts a double-quoted C-string from a buffer (also a C-string) containing a line of text.The last character of the line must be a double-quote ("). The first double-quote in theline will initiate the string. So the buffer pointed to by <linebuf> will look like this:    ^IN(9) "Bassoon 2"This function extracts "Bassoon 2" (without quotes) from this line. ??? NOT done yet!!The line may include double-quotes *between* the ones mentioned above as long as theyare escaped with a backslash (e.g.:  ^HT(1) "John \"Bonzo\" Bonham"). This functionwill remove the backslashes.Both vars are pointers to buffers allocated by the caller.<linebuf> may contain no more than LINELEN chars; <string> must contain 32 chars.This function does *not* alter the buffer pointed to by <linebuf>.Returns TRUE if ok, FALSE if error. */ static Boolean ExtractString(char	linebuf[],			/* pointer to source line buffer */									  char	string[])			/* pointer to buffer receiving extracted string */{	char	*p, *q, buf[LINELEN];		strncpy(buf, linebuf, (size_t)LINELEN);				/* copy line buffer */	p = strchr(buf, '"');										/* p should point to first '"' */	if (!p) goto broken;	p++;																/* advance pointer past quote */	q = p + (strlen(p)-1);										/* point to last char of string (NB: in case of "", p=q, which is right) */	if (*q=='"')		*q = '\0';													/* wipe out terminating '"' */	else		goto broken;												/* no terminating '"' */// ???Should remove any backslashes that escape '"'	GoodStrncpy(string, p, (unsigned long)31);	return TRUE;broken:	*string = '\0';	return FALSE;}/* ---------------------------------------------------------------------------------- *//* Functions for reporting on our ETF data structure. */#if LISTSCORE/* -------------------------------------------------------------------- ListScore -- */static void ListScore(void){	long	i;	short	j, hiStaff=0, thisStaff, thisL, lastL, thisNL, startTime;		/* get highest staff number */	for (i = 1; i<=gNumFrames; i++) {		thisStaff = gETF.pFrames[i].staffID;		if (hiStaff<thisStaff) hiStaff = thisStaff;	}		/* report contents of each staff in turn */	/* NB: this assumes that we will find a staff's measures in sequential order */	for (j = 1; j<=hiStaff; j++) {		/* ????start at 0 to catch orphaned frames? */		say("STAFF %d...........................................\n", j);		for (i = 1; i<=gNumFrames; i++) {			thisStaff = gETF.pFrames[i].staffID;			if (j==thisStaff) {				say("\t MEASURE %d:\n", gETF.pFrames[i].meas);				startTime = 0;				lastL = gETF.pFrames[i].lastL;				for (thisL = gETF.pFrames[i].firstL; thisL; thisL = gETF.pEntries[thisL].nextL) {					if (gETF.pEntries[thisL].startTuplet) {//						??????					}					say("\t   ENTRY %d: startTime=%d, dur=%d%s%s%s%s\n", thisL, startTime,									gETF.pEntries[thisL].dur,									gETF.pEntries[thisL].notBeamedFromPrev? ", notBeamedFromPrev" : "",									gETF.pEntries[thisL].startTuplet? ", startTuplet" : "",									gETF.pEntries[thisL].isRest? ", isRest" : "",									gETF.pEntries[thisL].isGrace? ", isGrace" : "");					for (thisNL = gETF.pEntries[thisL].firstNoteL; thisNL; thisNL = gETF.pNotes[thisNL].nextL) {						say("\t     halfline=%d, acc=%d%s%s%s\n",										gETF.pNotes[thisNL].halfline,										gETF.pNotes[thisNL].accidental,										gETF.pNotes[thisNL].hasAcc? ", hasAcc" : "",										gETF.pNotes[thisNL].tiedL? ", tiedL" : "",										gETF.pNotes[thisNL].tiedR? ", tiedR" : "");					}					if (!gETF.pEntries[thisL].isGrace)						startTime += gETF.pEntries[thisL].dur;					if (thisL==lastL) break;				/* don't go to next frame! */				}			}		}		say("\n");	}}#endif	/* #if LISTSCORE */#if LISTOBJECTS/* ------------------------------------------------------------------ ListObjects -- */static void ListObjects(void){#ifndef PUBLIC_VERSION	long	i;		say("PAGES..............................................\n");	for (i = 1; i<=gNumPages; i++) {		say(" (%ld)\t height=%d, wid=%d, startSys=%d, sizePct=%d, margins (t,l,b,r)=%d,%d,%d,%d\n", i,					gETF.pPages[i].height,					gETF.pPages[i].width,					gETF.pPages[i].startSys,					gETF.pPages[i].sizePct,					gETF.pPages[i].margins.top,					gETF.pPages[i].margins.left,					gETF.pPages[i].margins.bottom,					gETF.pPages[i].margins.right);	}	say("\n");	say("STAVES.............................................\n");	for (i = 1; i<=gNumStaves; i++) {		if (gETF.pStaves[i].staffNum==0) {			say(" (**)\t Empty node at %ld\n", i);			continue;		}		say(" (%ld)\t stfnum=%d, nLines=%d, vOffset=%d, group=%d, clef=%d, TSnum=%d, TSdenom=%d, name=\"%s\"\n", i,					gETF.pStaves[i].staffNum,					gETF.pStaves[i].numLines,					gETF.pStaves[i].vOffset,					gETF.pStaves[i].group,					gETF.pStaves[i].startClef,					gETF.pStaves[i].timeSigNum,					gETF.pStaves[i].timeSigDenom,					gETF.pStaves[i].fullname);	}	say("\n");	say("FRAMES.............................................\n");	for (i = 1; i<=gNumFrames; i++) {		if (gETF.pFrames[i].staffID==0) {			say(" (**)\t Empty node at %ld\n", i);			continue;		}		say(" (%ld)\t staffID=%d, layer=%d, meas=%d, firstL=%d, lastL=%d, wid=%d, %s%d\n", i,					gETF.pFrames[i].staffID,					gETF.pFrames[i].layerNum,					gETF.pFrames[i].meas,					gETF.pFrames[i].firstL,					gETF.pFrames[i].lastL,					gETF.pFrames[i].measWid,					gETF.pFrames[i].hasClefChange? "clefGrp=" : "clef=",					gETF.pFrames[i].startClef);	}	say("\n");	say("MEASURES...........................................\n");	for (i = 1; i<=gNumMeas; i++) {		say(" (%ld)\t measWid=%d, keySig=%d, TSnum=%d, TSdenom=%d\n", i,					gETF.pMeasures[i].measWid,					gETF.pMeasures[i].keySig,					gETF.pMeasures[i].timeSigNum,					gETF.pMeasures[i].timeSigDenom);	}	say("\n");	say("ENTRIES............................................\n");	for (i = 1; i<=gNumEntries; i++) {		if (gETF.pEntries[i].validNode==FALSE) {			say(" (**)\t Empty node at %ld\n", i);			continue;		}		say(" (%ld)\t prevL=%d, nextL=%d, frameL=%d, firstNoteL=%d, dur=%d%s%s%s%s%s%s%s%s\n", i,					gETF.pEntries[i].prevL,					gETF.pEntries[i].nextL,					gETF.pEntries[i].frameL,					gETF.pEntries[i].firstNoteL,					gETF.pEntries[i].dur,										gETF.pEntries[i].isGrace? ", isGrace" : "",					gETF.pEntries[i].isRest? ", isRest" : "",					gETF.pEntries[i].inVoice2? ", inVoice2" : "",					gETF.pEntries[i].stemFrozenUp? ", stemFrozenUp" : "",					gETF.pEntries[i].hasChordSym? ", hasChordSym" : "",					gETF.pEntries[i].hasArticMark? ", hasArticMark" : "",					gETF.pEntries[i].startTuplet? ", startTuplet" : "",					gETF.pEntries[i].notBeamedFromPrev? ", notBeamedFromPrev" : "");	}	say("\n");	say("NOTES..............................................\n");	for (i = 1; i<=gNumNotes; i++) {		say(" (%ld)\t entryL=%d, nextL=%d, halfLn=%d, acc=%d%s%s%s%s\n", i,					gETF.pNotes[i].entryL,					gETF.pNotes[i].nextL,					gETF.pNotes[i].halfline,					gETF.pNotes[i].accidental,					gETF.pNotes[i].hasAcc? ", hasAcc" : "",					gETF.pNotes[i].tiedL? ", tiedL" : "",					gETF.pNotes[i].tiedR? ", tiedR" : "",					gETF.pNotes[i].crossStaff? ", crossStaff" : "");	}	say("\n");	say("TUPLETS............................................\n");	for (i = 1; i<=gNumTuplets; i++) {		char tuplefmt[32];		switch (gETF.pTuplets[i].format) {			case ETFTUPLET_NOTHING:			strcpy(tuplefmt, "nothing");				break;			case ETFTUPLET_NUMONLY:			strcpy(tuplefmt, "numonly");				break;			case ETFTUPLET_NUMSLUR:			strcpy(tuplefmt, "num w/ slur");			break;			case ETFTUPLET_NUMBRACKET:		strcpy(tuplefmt, "num w/ bracket");		break;		}		say(" (%ld)\t entryL=%d, accNum=%d, numDurUnit=%d, accDenom=%d, denomDurUnit=%d\n", i,					gETF.pTuplets[i].entryL,					gETF.pTuplets[i].accNum,					gETF.pTuplets[i].numDurUnit,					gETF.pTuplets[i].accDenom,					gETF.pTuplets[i].denomDurUnit);		say("\t\t %s%s\n", tuplefmt, gETF.pTuplets[i].useRatio? ", useRatio" : "");	}	say("\n");	say("CLEFS..............................................\n");	for (i = 1; i<=gNumClefs; i++) {		say(" (%ld)\t clefGrp=%d, frame=%d, stTime=%d, vOfst=%d, szPct=%d, clef=%d\n", i,					gETF.pClefs[i].clefGroup,					gETF.pClefs[i].frameL,					gETF.pClefs[i].startTime,					gETF.pClefs[i].vOffset,					gETF.pClefs[i].sizePct,					gETF.pClefs[i].clefType);	}	say("\n");	say("CONNECTS...........................................\n");	for (i = 1; i<=gNumConnects; i++) {		say(" (%ld)\t group=%d, type=%d, xOffset=%d/*, vAdjTop=%d, vAdjBot=%d*/\n", i,					gETF.pConnects[i].group,					gETF.pConnects[i].type,#ifdef NOTYET					gETF.pConnects[i].xOffset,					gETF.pConnects[i].vAdjustTop,					gETF.pConnects[i].vAdjustBot);#else					gETF.pConnects[i].xOffset);#endif	}#endif /* PUBLIC_VERSION */}#endif	/* #if LISTOBJECTS *//* ----------------------------------------------------------- ReportParseFailure -- */static void ReportParseFailure(char	*functionName)					/* C string */{	MayErrMsg("%s: Problem parsing line number %ld in ETF file:\n%s",					functionName, gLineCount, gInBuf);}/* ------------------------------------------------------- SupportedEnigmaVersion -- *//* If the input file is a version of Enigma that we support, return TRUE, else return FALSE.Assumes that the file position indicator is at the top of the file.NB: This function advances the file position indicator. */#define ETF_FIRSTLINE		"ENIGMA TRANSPORTABLE FILE"	/* 1st line of an Enigma file (>= v. 3.0) */#define ETF_OLDFIRSTLINE	"ENIGMA transportable file"	/* 1st line of an Enigma file (< v. 3.0) */static Boolean SupportedEnigmaVersion(FILE *f){	short		ans,				errIndex = 1;						/* index of error string in ENIGMA_STRS 'STR#' */ 	char		versionStr[32];	short		versionWhole, versionTenths;		/* See if file starts with "ENIGMA TRANSPORTABLE FILE" */	if (!ReadLine(gInBuf, LINELEN, f)) goto err;	if (strcmp(gInBuf, ETF_FIRSTLINE)) {		if (!strcmp(gInBuf, ETF_OLDFIRSTLINE)) errIndex = 2;						/* give more informative alert */		goto err;	}	if (!ReadLine(gInBuf, LINELEN, f)) goto err;										/* skip 2 lines */	if (!ReadLine(gInBuf, LINELEN, f)) goto err;	/* Read 4th line of file, which should something look like this:	 *   ^01 "Finale(R) 3.2 Copyright (c) 1994 Coda Music Technology."	 * The version must not be less than 3.0.	 */	if (!ReadLine(gInBuf, LINELEN, f)) goto err;	/* We want to use the following sscanf:	 * 	ans = sscanf(gInBuf, "%*s%*s%f", &version);	 * However, we've been using THINK's ANSI-small library, which doesn't support	 * floating point. I'd switch to the full ANSI library now, but I don't want to	 * risk bugs--it's too close to shipping (I hope). Instead, we'll parse the	 * digits ourselves.	 */	   ans = sscanf(gInBuf, "%*s%*s%s", versionStr);	   if (ans!=1) goto err;		versionWhole = (versionStr[0]-'0');						/* Valid for ASCII */	   versionTenths = (versionStr[2]-'0');					/* Valid for ASCII */		#ifdef SUPPORT_V35   /* Accept only whole version number 3 and tenths digit 0, 1, 2 or 5 as valid.		(We've tested only files created by v. 3.0, v. 3.2 and v. 3.5; since these 		work, surely 3.1 does also. We don't know if there even is a 3.3 or 3.4.) */	if (versionWhole!=3 || (versionTenths<0 || versionTenths>5)) {		errIndex = 2;		goto err;	}	else		gETFVersion = (float)versionWhole + ((float)versionTenths)/10;#else	   /* Accept only whole version number 3 and tenths digit 0, 1, or 2 as valid.	    * (We've tested only files created by v. 3.0 and v. 3.2; since these work,	    * surely 3.1 does also.) */	if (versionWhole!=3 || (versionTenths<0 || versionTenths>2)) {		errIndex = 2;		goto err;	}#endif /* SUPPORT_V35 */	return TRUE;err:#ifdef Nightmare95	SimpleStopInform(ENIGMA_STRS, errIndex);#else	GetIndCString(strBuf, ENIGMA_STRS, errIndex);	CParamText(strBuf, "", "", "");	StopInform(GENERIC_ALRT);#endif	return FALSE;}/* ---------------------------------------------------------------------------------- *//* Functions that call Macintosh Toolbox routines. *//* -------------------------------------------------------------- ParseTextBlocks -- *//* When this function is called, gInBuf contains at least "^text". If there are any text blocksin the file, their contents will appear after this tag, with no intervening white space. Forexample, if a file has one text block containing the string "Sample text for a text block",the ^text line looks like this: "^text^block(1)Sample text for a text block"Since multiple text blocks appear on this line without any embedded newlines, the line mightbe far too long to fit in gInBuf. So ParseTextBlocks reads as much of the file as necessaryto pull in all the text on this line.The text contained in each block is preceded by a tag, "^block(x)", where x is the text block ID.Note that text blocks encode different fonts and styles with a cumbersome system oftags, so that, for example, the word "foo" in Palatino italic looks like this:    "^font(Palatino)^efx(plain)^efx(italic)foo"Since Nightingale does not yet support styled text in text blocks (or even embedded carriagereturns, for that matter), we just strip out all these tags. */ static Boolean ParseTextBlocks(void){	/* First see if there are any text blocks to worry about. */	if (strcmp(gInBuf, gETFcodes[TEXT])==0)		return TRUE;												/* No, gInBuf contains only "^text" */		// ??under construction, along the lines of ParseLyrics...		return TRUE;broken:	ReportParseFailure("ParseTextBlocks");	return FALSE;}/* ------------------------------------------------------------------------- ParseLyrics -- *//* When this function is called, gInBuf contains at least "^lyrics". If there are anylyrics in the file, their contents will appear after this tag, with no intervening whitespace. For example, if a file has one lyric verse containing the string "I'll be cryin'in my beer tonite", the ^lyric line would probably look like this:   "^lyrics^verse(1)I'll be cry-in' in my beer to-nite"Since multiple verses appear on this line without any embedded newlines, the line mightbe far too long to fit in gInBuf. So ParseLyrics reads as much of the file as necessaryto pull in all the text on this line.The text contained in each verse is preceded by a tag, "^verse(x)", where x is the versenumber. Note that lyric text may have mixed fonts and styles; these are encoded using acumbersome system of tags, so that, for example, the word "beer" in Helvetica bold lookslike this:    "^font(Helvetica)^efx(plain)^efx(bold)beer"Since Nightingale does not yet support styled text in lyrics, we just strip out allthese tags.???For now, we just store all lyrics into the first slot of the gETF.pLyrics array, afterstripping out all of the tags described above. */static Boolean ParseLyrics(FILE *f){	Ptr		pTmp;	Handle	hBuf;	char		*p;	long		len, insertAt, i;	Size		size;	Boolean	moreLeft;		/* First see if there is any lyric text to worry about. */	if (strcmp(gInBuf, gETFcodes[LYRICS])==0)		return TRUE;														/* No, gInBuf contains only "^lyrics" */		/* There might be more text on the line that did not fit into our buffer.		If so, ReadLine will have clipped it and placed a terminating null at		the end of the buffer. If the buffer is full, we assume that we might		not have gotten the entire line, and so we continue to read it.		We create a new buffer, hBuf, to hold all the lyric text,		and terminate it with a null (to make subsequent code easier). */	hBuf = NewHandle((Size)1L);										/* we'll need terminating null for hBuf */	if (!GoodNewHandle(hBuf)) {		NoMoreMemory();		return FALSE;	}	moreLeft = TRUE;	insertAt = 0L;	do {		len = strlen(gInBuf);											/* length of buffer, not including terminating null */		if (len<LINELEN-1)												/* (If buffer full, gInBuf[LINELEN-1] will be null.) */			moreLeft = FALSE;		size = GetHandleSize(hBuf);		SetHandleSize(hBuf, size+len);								/* make room for this line at end of pointer */		if (MemError()) {			DisposeHandle(hBuf);			NoMoreMemory();			return FALSE;		}		HLock(hBuf);														// unnecessary for BlockMove?		BlockMove(gInBuf, &((*hBuf)[insertAt]), len);		HUnlock(hBuf);		insertAt += len;		if (moreLeft) {			ReadLine(gInBuf, LINELEN, f);		// test this?? If EOF without reading a char, this will be false, but that might be ok.		}	} while (moreLeft);	size = GetHandleSize(hBuf);	(*hBuf)[size-1] = '\0';												/* terminate buffer with null, for string manipulation below */	len = size-1;#ifdef NOTYET	/* Now the text of all lyric verses is in the null-terminated block pointed to 	 * by hBuf. It includes the initial ^lyric tag, the verse tags and any font/style	 * tags. We discard the ^lyric tag, use the verse tags to assign lyric chunks	 * to records in the gETF.pLyrics array, and discard the other tags.	 */#else	/* For now, just strip out all the tags and store the lyrics into gETF.pLyrics[0].pText,	 * which we allocate here.	 */	pTmp = NewPtr((Size)(len));	if (!GoodNewPtr(pTmp)) {		DisposeHandle(hBuf);		NoMoreMemory();		return FALSE;	}		/* Copy bytes that aren't part of tags into pTmp. A tag begins with '^'	 * and ends with ')'.	 */	HLock(hBuf);	p = *hBuf;	p += strlen(gETFcodes[LYRICS]);							/* skip over the ^lyrics tag */	i = 0L;	while (*p) {		if (*p=='^') {												/* we've hit a tag */			p = strchr(p, ')');									/* p will point to ')' */			if (p)				p++;													/* advance pointer to character following ')' */			else goto broken;									// ??bad tag		}		if (*p=='^')												/* we've hit another tag */			continue;		else if (*p==0xCA) p += 2;								/* skip opt-space (& following space) that tells Finale to skip a note when assigning lyrics */		else			pTmp[i++] = *p++;										/* copy one lyric char; advance ptr */	}	SetPtrSize(pTmp, i);	if (MemError()!=noErr) goto broken;		/* ??The "Byte" type is misleading: this is a char. string, but non-NULL-terminated. */ 	gETF.pLyrics[0].pText = (Byte *) pTmp;#endif		DisposeHandle(hBuf);	return TRUE;broken:	DisposeHandle(hBuf);	ReportParseFailure("ParseLyrics");	return FALSE;}	/* ------------------------------------------------------------------- GetETFFile -- */#ifdef TARGET_API_MAC_CARBON_FILEIOstatic short GetETFFile(Str255 /*macfName*/, short */*vRefNum*/){	return FALSE;}#elsestatic short GetETFFile(Str255 macfName, short *vRefNum){	SFTypeList	myTypes;	SFReply		reply;	Point			dialogWhere = { 90, 82 };		myTypes[0] = 'ETF3';	myTypes[1] = 'TEXT';		SFGetFile(dialogWhere, "\p", 0L, 2, myTypes, 0L, &reply);	if (reply.good) {		PStrCopy(reply.fName, macfName);		*vRefNum = reply.vRefNum;		return TRUE;	}	return FALSE;}#endif // TARGET_API_MAC_CARBON_FILEIO/* --------------------------------------------------------------- AllocETFMemory -- *//*	Allocate memory for Enigma objects. Assumes globals giving numbers of Enigma objects(e.g., gNumFrames) have been assigned correctly. Returns TRUE if ok, FALSE if error(after giving NoMoreMemory alert). NB: In the case of an error here, a function higherin the calling chain should dispose of whatever memory was allocated before the errorby calling DisposETFMemory. NB: We use NewPtrClear rather than NewPtr to insure thatall fields will be set to zero. */static Boolean AllocETFMemory(void){	Ptr	p;		/* Must init to NULL so that if we fail partway through allocation,	 * the subsequent call to DisposETFMemory will be safe.	 */	gETF.pFrames = (PETF_FRAME)NULL;	gETF.pMeasures = (PETF_MEAS)NULL;	gETF.pStaves = (PETF_STAFF)NULL;	gETF.pSystems = (PETF_SYSTEM)NULL;	gETF.pOptimizedStaves = (PETF_OPTIMIZEDSTAFF)NULL;	gETF.pPages = (PETF_PAGE)NULL;	gETF.pEntries = (PETF_ENTRY)NULL;	gETF.pNotes = (PETF_NOTE)NULL;	gETF.pTuplets = (PETF_TUPLET)NULL;	gETF.pClefs = (PETF_CLEF)NULL;	gETF.pConnects = (PETF_CONNECT)NULL;#ifdef NOTYET	gETF.pTextBlocks = (PETF_TEXTBLOCK)NULL;#endif	gETF.pLyrics = (PETF_LYRIC)NULL;	gpTmpGFRecs = (PTMPGFREC)NULL;	/* Allocate a non-relocatable block for each type of data. */		p = NewPtrClear((Size) ((gNumFrames+1) * sizeof(ETF_FRAME)) );	if (!GoodNewPtr(p)) { p = NULL; goto broken; }	gETF.pFrames = (PETF_FRAME) p;	p = NewPtrClear((Size) ((gNumMeas+1) * sizeof(ETF_MEAS)) );	if (!GoodNewPtr(p)) { p = NULL; goto broken; }	gETF.pMeasures = (PETF_MEAS) p;	p = NewPtrClear((Size) ((gNumStaves+1) * sizeof(ETF_STAFF)) );	if (!GoodNewPtr(p)) { p = NULL; goto broken; }	gETF.pStaves = (PETF_STAFF) p;	p = NewPtrClear((Size) ((gNumSystems+1) * sizeof(ETF_SYSTEM)) );	if (!GoodNewPtr(p)) { p = NULL; goto broken; }	gETF.pSystems = (PETF_SYSTEM) p;	p = NewPtrClear((Size) ((gNumOptimizedStaves+1) * sizeof(ETF_OPTIMIZEDSTAFF)) );	if (!GoodNewPtr(p)) { p = NULL; goto broken; }	gETF.pOptimizedStaves = (PETF_OPTIMIZEDSTAFF) p;	p = NewPtrClear((Size) ((gNumPages+1) * sizeof(ETF_PAGE)) );	if (!GoodNewPtr(p)) { p = NULL; goto broken; }	gETF.pPages = (PETF_PAGE) p;		p = NewPtrClear((Size) ((gNumEntries+1) * sizeof(ETF_ENTRY)) );	if (!GoodNewPtr(p)) { p = NULL; goto broken; }	gETF.pEntries = (PETF_ENTRY) p;	p = NewPtrClear((Size) ((gNumNotes+1) * sizeof(ETF_NOTE)) );	if (!GoodNewPtr(p)) { p = NULL; goto broken; }	gETF.pNotes = (PETF_NOTE) p;	p = NewPtrClear((Size) ((gNumTuplets+1) * sizeof(ETF_TUPLET)) );	if (!GoodNewPtr(p)) { p = NULL; goto broken; }	gETF.pTuplets = (PETF_TUPLET) p;		p = NewPtrClear((Size) ((gNumClefs+1) * sizeof(ETF_CLEF)) );	if (!GoodNewPtr(p)) { p = NULL; goto broken; }	gETF.pClefs = (PETF_CLEF) p;		p = NewPtrClear((Size) ((gNumConnects+1) * sizeof(ETF_CONNECT)) );	if (!GoodNewPtr(p)) { p = NULL; goto broken; }	gETF.pConnects = (PETF_CONNECT) p;#ifdef NOTYET	p = NewPtrClear((Size) ((gNumTextBlocks+1) * sizeof(ETF_TEXTBLOCK)) );	if (!GoodNewPtr(p)) { p = NULL; goto broken; }	gETF.pTextBlocks = (PETF_TEXTBLOCK) p;#endif	p = NewPtrClear((Size) ((gNumLyrics+1) * sizeof(ETF_LYRIC)) );	if (!GoodNewPtr(p)) { p = NULL; goto broken; }	gETF.pLyrics = (PETF_LYRIC) p;	/* NB: allocate this tmp array last! (In case of error, it would not be disposed		by DisposETFMemory.) */	p = NewPtrClear((Size) ((gNumGFRecs) * sizeof(TMPGFREC)) );	if (!GoodNewPtr(p)) { p = NULL; goto broken; }	gpTmpGFRecs = (PTMPGFREC) p;	#if OTHERDEBUG{ long sz = GetPtrSize(p); say("Entries ptr = %ld bytes\n\n", sz); }#endif	return TRUE;broken:	NoMoreMemory();	return FALSE;}/* -------------------------------------------------------------- DisposETFMemory -- */void DisposETFMemory(void){	if (gETF.pFrames) DisposePtr((char *)gETF.pFrames);	if (gETF.pMeasures) DisposePtr((char *)gETF.pMeasures);	if (gETF.pStaves) DisposePtr((char *)gETF.pStaves);	if (gETF.pSystems) DisposePtr((char *)gETF.pSystems);	if (gETF.pOptimizedStaves) DisposePtr((char *)gETF.pOptimizedStaves);	if (gETF.pPages) DisposePtr((char *)gETF.pPages);	if (gETF.pEntries) DisposePtr((char *)gETF.pEntries);	if (gETF.pNotes) DisposePtr((char *)gETF.pNotes);	if (gETF.pTuplets) DisposePtr((char *)gETF.pTuplets);	if (gETF.pClefs) DisposePtr((char *)gETF.pClefs);	if (gETF.pConnects) DisposePtr((char *)gETF.pConnects);#ifdef NOTYET	/* see treatment of lyrics below */	if (gETF.pTextBlocks) DisposePtr((char *)gETF.pTextBlocks);#endif	if (gETF.pLyrics) {		/* First dispose pText pointer contained within each pLyrics struct. */#ifdef NOTYET#else		if (gETF.pLyrics[0].pText) DisposePtr((char *)gETF.pLyrics[0].pText);#endif		/* Now dispose the block of structs */		DisposePtr((char *)gETF.pLyrics);	}		gETF.pFrames = (PETF_FRAME)NULL;	gETF.pMeasures = (PETF_MEAS)NULL;	gETF.pStaves = (PETF_STAFF)NULL;	gETF.pSystems = (PETF_SYSTEM)NULL;	gETF.pOptimizedStaves = (PETF_OPTIMIZEDSTAFF)NULL;	gETF.pPages = (PETF_PAGE)NULL;	gETF.pEntries = (PETF_ENTRY)NULL;	gETF.pNotes = (PETF_NOTE)NULL;	gETF.pTuplets = (PETF_TUPLET)NULL;	gETF.pClefs = (PETF_CLEF)NULL;	gETF.pConnects = (PETF_CONNECT)NULL;#ifdef NOTYET	gETF.pTextBlocks = (PETF_TEXTBLOCK)NULL;#endif	gETF.pLyrics = (PETF_LYRIC)NULL;}/* -------------------------------------------------------------- DisposTmpMemory -- */static void DisposTmpMemory(void){	if (gpTmpGFRecs) DisposePtr((char *)gpTmpGFRecs);	gpTmpGFRecs = (PTMPGFREC)NULL;}#endif /* !LIGHT_VERSION */