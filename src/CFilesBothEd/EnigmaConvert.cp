/****************************************************************************	FILE:	EnigmaConvert.c																	**	PROJ:	Nightingale, new for v 3.1														**	DESC:	Routines for converting Enigma Transportable Format files to		**			Nightingale format. Written by John Gibson.								*/***************************************************************************//*											NOTICE * * THIS FILE IS PART OF THE NIGHTINGALEª PROGRAM AND IS CONFIDENTIAL PROP- * ERTY OF ADVANCED MUSIC NOTATION SYSTEMS, INC.  IT IS CONSIDERED A TRADE * SECRET AND IS NOT TO BE DIVULGED OR USED BY PARTIES WHO HAVE NOT RECEIVED * WRITTEN AUTHORIZATION FROM THE OWNER. * * Copyright © 1996-98 by Advanced Music Notation Systems, Inc. All Rights Reserved. */#include "Nightingale_Prefix.pch"#include "Nightingale.appl.h"#ifndef LIGHT_VERSION/* ---------------------------------------------------------------------------------- *//* Local prototypes */static short ETFtoNight(Document *doc);static short ConvertSystem(Document *doc, short firstMeasn, short lastMeasn);static LINK ConvertMeasure(Document *doc, short measn, Boolean firstMeasOfSystem);static Boolean CheckKeysigChange(Document *doc, short measn, Boolean firstMeasOfSystem);static Boolean CheckTimesigChange(Document *doc, short measn, Boolean firstMeasOfSystem);static Boolean CheckClefChange(Document *doc, short entryL, FASTFLOAT startTime, short staffn, Boolean firstMeasOfSystem);static Boolean CheckTuplet(Document *doc, short staffn, short iVoice, short entryL, LINK syncL, FASTFLOAT *entryETFdur, ETFTUPLEPARAM *pTupleParam);static Boolean ConvertFrame(Document *doc, short layern, short staffn, short frameL, Boolean firstMeasOfSystem);static Boolean ConvertEntryNotes(Document *doc, LINK syncL, short staffn, short iVoice, short entryL, short lDur, short ndots, FASTFLOAT startTime, short xOffset);static Boolean InsertPlaceholderRest(Document *doc, LINK insertBeforeL, short staffn, short iVoice, short restETFdur);static Boolean DeleteAllPlaceholderRests(Document *doc);static Boolean OptimizeAllSystems(Document *doc);static short CountStavesInETFGroup(short groupNum);static Boolean Likely2StaffPart(short groupNum);static short SetupETFscore(Document *doc);static Document *CreateETFdoc(unsigned char *fileName);static Boolean BuildETFdoc(Document *doc, long *version, short pageWidth,  short pageHt, short nStaves, short rastral);static void DisplayETFdoc(Document *newDoc);static Boolean AssignVoices(Document *doc);static short ETF2NightClef(short ETFClef);static short Night2ETFClef(short nightClef);static Boolean ETF2NightTimeSig(short ETFnum, short ETFdenom, short *nightNum, short *nightDenom, Boolean *isCompound);static short ETF2NightDur(short EDUdur, short *pLDur, short *pNdots);static char ETF2NightHalfLn(short thisEL, short thisNL, FASTFLOAT startTime, short type);static char ETFtoNightKeysig(short ETFkeysig);static Boolean StaffIsVisible(short systemNum, short staffn);static short CountETFChord(short entryL);static short CountETFTupletEntries(short tupletID);static Boolean CountEntriesInFrame(short frameL, short *numV1Entries, short *numV2Entries);static Boolean GetETFTuplet(short thisEL, short *tupletID);static short GetETFFrameL(short staffn, short measn, short layern);static short GetETFEntryStaff(short noteL);static short GetETFStaffID(short staffn);static Boolean GetETFSysRangeForPage(short ETFpg, short *startSys, short *endSys);static Boolean GetETFMeasRangeForSystem(short ETFsys, short *startMeas, short *endMeas);static char GetETFClef(short entryL, FASTFLOAT startTime);static Boolean GetETFTimeSig(short measL, short staffn, short *timeSigNum, short *timeSigDenom);static Boolean GetETFKeySig(short measL, short staffn, short *keySig);static char GetETFRaiseLowerAcc(short noteL);static char GetETFAbsoluteHalfLn(short entryL, short noteL);static short GetETFRastral(short pgSzPct, short sysSzPct, short stfSzPct);static Boolean ValidETFTuplet(short tupletID);static void DisplayNightDS(Document *doc, Boolean check, Boolean showLinks, Boolean showSubs);static void BuildConvertedETFFileName(Str255 fn, Str255 newfn);static Boolean SaveLyrics(Str255 fileName);/* ---------------------------------------------------------------------------------- *//* Constants */enum {								/* type of Ngale half-line value to retrieve from ETF2NightHalfLn */	MIDDLEC_REL_HALFLN=0,	STAFF_REL_HALFLN};/* ---------------------------------------------------------------------------------- *//* Globals declared in EnigmaParse.c */extern ETF	gETF;extern unsigned short	gNumStaves,								gNumStavesUsed,								gNumFrames,								gNumMeas,								gNumEntries,								gNumNotes,								gNumTuplets,								gNumPages,								gNumSystems,								gNumOptimizedStaves,								gNumClefs,								gNumConnects,								gNumTextBlocks,								gNumLyrics;/* ---------------------------------------------------------------------------------- *//* ------------------------------------------------------------------- OpenETFFile -- *//* The top level, public function. */Boolean OpenETFFile(void){	Boolean		success = FALSE;	Str255		ETFfileName, newfn;	Document		*doc;	char			configDisableUndo;	Boolean		ok;	ok = ParseETFFile(ETFfileName);	if (!ok) return FALSE;#if CONVERTSCORE	BuildConvertedETFFileName(ETFfileName, newfn);	doc = CreateETFdoc(newfn);	if (doc==NULL) {		GetIndCString(strBuf, ENIGMA_STRS, 3);		CParamText(strBuf, "", "", "");		StopInform(GENERIC_ALRT);		goto err;	}	configDisableUndo = config.disableUndo;						/* Save this. */	config.disableUndo = TRUE;											/* In case we invoke PrepareUndo. */		success = (ETFtoNight(doc)==0);		config.disableUndo = configDisableUndo;#if SHOW_PROGRESSWINDOW	ProgressMsg(0, "");													/* Remove progress window. */#endif	if (success)	{		(void)SaveLyrics(ETFfileName);		DisplayETFdoc(doc);	}	else {		doc->changed = FALSE;		DoCloseDocument(doc);	}#endiferr:#if SHOW_PROGRESSWINDOW	ProgressMsg(0, "");										/* Remove progress window, if it hasn't already been removed. */#endif	DisposETFMemory();	return (success);}/* ---------------------------------------------------------------------------------- *//* Functions for translating the ETF data structure into a Nightingale score */// In Slurs.c, create two new functions, to be called only from// ETFtoNight for now. Later we'll want to reorganize this, but doing it// this way will avoid any side effects. The ETF code uses these two// functions instead of CreateAllTies and CreateTies, in order to avoid// some screwups and complaints when trying to create cross-system ties.// Later this should be made to support cross-system ties and should be// moved into FileInput.c, if possible (would require rewrite of Slurs.c).static void FICreateAllTies(Document *doc);								// public prototype, belongs in Slurs.hstatic void FICreateTies(Document *doc, LINK pL, LINK aNoteL);		// local prototype/* ---------------------------------------------------------------- FICreateTies -- *//* Create a set of ties for aNoteL and all other notes in its voice in pL that havecorresponding notes in the next Sync in its voice that are tiedL.NB: FICreateTies is like CreateTies, except in two respects:	1) If a tie from pL would be a cross-system tie, don't try to create it. 	2) Don't give error messages if, for any reason, the tie creation fails.*/static void FICreateTies(Document *doc, LINK pL, LINK aNoteL) {	LINK qL, bNoteL; PANOTE aNote, bNote;		aNote = GetPANOTE(aNoteL);	if (aNote->tiedR) {		qL = LVSearch(RightLINK(pL), SYNCtype, NoteVOICE(aNoteL), GO_RIGHT, FALSE);		if (qL) {			if (!SameSystem(pL, qL)) return;		/* don't try to create cross-system tie */			bNoteL = FirstSubLINK(qL);			for ( ; bNoteL; bNoteL=NextNOTEL(bNoteL))				if (NoteVOICE(bNoteL)==NoteVOICE(aNoteL) && MainNote(bNoteL)) {					bNote = GetPANOTE(bNoteL);					if (bNote->tiedL)						AddNoteTies(doc, pL, qL, NoteSTAFF(aNoteL), NoteVOICE(aNoteL));				}		}	}}/* --------------------------------------------------------------- FICreateAllTies -- *//* Assuming the given score has notes with their tiedR/tiedL flags set appropriatelybut no corresponding Slur objects describing the ties, generate Slur objects for allthose notes. Does not check whether they already have Slurs! NB: FICreateAllTies is the same as CreateAllTies, except that it calls FICreateTiesrather than CreateTies. */ void FICreateAllTies(Document *doc){	LINK pL,aNoteL;		for (pL=doc->headL; pL!=doc->tailL; pL=RightLINK(pL))		if (SyncTYPE(pL)) {			aNoteL = FirstSubLINK(pL);			for ( ; aNoteL; aNoteL=NextNOTEL(aNoteL))				if (MainNote(aNoteL))					FICreateTies(doc, pL, aNoteL);		}}/* -------------------------------------------------------------------- ETFtoNight -- */static short ETFtoNight(Document *doc){	short		err, ETFpg, NGpg, sysn, startSys, endSys, startMeas, endMeas;	long		spacePercent;	LINK		firstMeasL, newSysL, newPageL, pL;	DDIST		sysTop, sysHt;	DRect		sysRect;	Boolean	ok, doReformat;		SetupETFscore(doc);		ok = AssignVoices(doc);	if (!ok) return (NoGood);		doc->autoRespace = FALSE;	// ?? in case CompactVoices tries to respace?	/* Finale scores that have never been in page view have insufficient formatting	 * information. In that case, just let Nightingale reformat the score as if sees fit.	 */	doReformat = (gNumSystems==1 && gETF.pSystems[1].startMeasNext==2);		if (doReformat) {		err = ConvertSystem(doc, 1, gNumMeas);		if (err) return (err);	}	else {			for (ETFpg = 1, NGpg = 1; ETFpg<=gNumPages; ETFpg++, NGpg++) {			if (gETF.pPages[ETFpg].startSys<1) {								/* It's a blank page. */				NGpg--;				continue;	//???do we reach NGpg++ before entering loop body again??			}			if (NGpg>1) {				newPageL = CreatePage(doc, LeftLINK(doc->tailL));			/* Create new page containing one system */				if (newPageL==NILINK) return (NoGood);				sysTop = SYS_TOP(doc);			}			else				sysTop = SYS_TOP(doc) + pt2d(config.titleMargin);			/* Page already created in BuildETFdoc */			newSysL = LSSearch(doc->tailL, SYSTEMtype, ANYONE, GO_LEFT, FALSE);			sysRect = SystemRECT(newSysL);			sysHt = sysRect.bottom - sysRect.top;			sysTop += sysHt;															/* for next system on this page, if any */				ok = GetETFSysRangeForPage(ETFpg, &startSys, &endSys);			if (!ok || (startSys==0 && endSys==0)) goto unfinished;		/* shouldn't get here if page is blank */						for (sysn = startSys; sysn<=endSys; sysn++) {				if (sysn>startSys) {													/* Create new system after first system on this page */					newSysL = CreateSystem(doc, LeftLINK(doc->tailL), sysTop, succSystem);					if (newSysL==NILINK) return (NoGood);					sysRect = SystemRECT(newSysL);					sysHt = sysRect.bottom - sysRect.top;					sysTop += sysHt;													/* for next system on this page, if any */				}				ok = GetETFMeasRangeForSystem(sysn, &startMeas, &endMeas);				if (!ok) goto unfinished;					err = ConvertSystem(doc, startMeas, endMeas);				if (err) return (err);			}		}	}unfinished:		/* in case we converted part of score before error? */	DeleteAllPlaceholderRests(doc);	/* Respace entire score to 100%, shrinking where necessary to preserve Enigma system breaks. */	SelAllNoHilite(doc);	firstMeasL = LSSearch(doc->headL, MEASUREtype, ANYONE, GO_RIGHT, FALSE);	doc->autoRespace = TRUE;	spacePercent = doc->spacePercent = 100L;	ok = RespaceBars(doc, firstMeasL, doc->tailL, RESFACTOR*spacePercent, FALSE, doReformat);	FIJustifyAll(doc);															/* Justify every system. */	#if DOAUTOBEAM	SelAllNoHilite(doc);	ok = AutoBeam(doc);#endif	/* Set tuplet accessory nums to a reasonable vertical position. Do *after* beaming! */	for (pL = doc->headL; pL!=doc->tailL; pL = RightLINK(pL))		if (TupletTYPE(pL))			SetTupletYPos(doc, pL);	FICreateAllTies(doc);#ifdef JG_NOTELIST	FIFixAllNoteSlurTieFlags(doc);#else	FixAllNoteTieFlags(doc);#endif	ok = OptimizeAllSystems(doc);	DeselRangeNoHilite(doc, doc->headL, doc->tailL);	SetDefaultSelection(doc);	doc->selStaff = 1;	MEAdjustCaret(doc, FALSE);	return (0);										/* everything ok */}/* ----------------------------------------------------------------- ConvertSystem -- */static short ConvertSystem(Document *doc, short firstMeasn, short lastMeasn){	register short	measn;	LINK				firstMeasL, termMeasL;		if (firstMeasn>lastMeasn) return (NoGood);		/* Convert each measure in turn. */	for (measn = firstMeasn; measn<=lastMeasn; measn++) {		termMeasL = ConvertMeasure(doc, measn, (measn==firstMeasn));		if (termMeasL==NILINK)			return (NoGood);			#ifdef DISPLAY_NOCOMPACTFixTimeStamps(doc, doc->headL, NILINK);#else		/* Select everything in that measure. */		firstMeasL = LSSearch(LeftLINK(termMeasL), MEASUREtype, ANYONE, GO_LEFT, FALSE); // ??NB: assumes meas isn't empty!		doc->selStartL = RightLINK(firstMeasL);		doc->selEndL = termMeasL;		SelectRange(doc, doc->selStartL, doc->selEndL, 1, doc->nstaves);		/* Compact all voices in that measure. */		if (!CompactVoices(doc))			return (NoGood);#endif				/* Deselect everything, because next SelectRange in loop iteration does not deselect (?) */		DeselAllNoHilite(doc);	}	#ifdef DISPLAY_NOCOMPACTDisplayNightDS(doc, TRUE, TRUE, TRUE);#endif	return (0);}/* ---------------------------------------------------------------- ConvertMeasure -- *//* Assemble a measure's worth of music on all staves. Return link of terminatingbarline if all is well; else return NILINK. */#define NUMLAYERS	4					/* number of layers in a Finale score */static LINK ConvertMeasure(Document *doc, short measn, Boolean firstMeasOfSystem){	short				staffn, layern, frameL, voice, barlineType;	LINK				measL;	Boolean			ok;	if (measn>1) {		ok = CheckKeysigChange(doc, measn, firstMeasOfSystem);		if (!ok) return (NILINK);		ok = CheckTimesigChange(doc, measn, firstMeasOfSystem);		if (!ok) return (NILINK);	}	#ifdef NOTYET	for (staffn = 1; staffn<=doc->nstaves; staffn++) {		Boolean	insWholeMeasRest = FALSE;		for (layern = 1; layern<=NUMLAYERS; layern++) {			frameL = GetETFFrameL(staffn, measn, layern);			if (frameL==NoGood) return (NILINK);			if (frameL) {				insWholeMeasRest = FALSE;							/* If any layer non-empty, don't make whole-meas rest. */				ok = ConvertFrame(doc, layern, staffn, frameL, firstMeasOfSystem);#ifdef NOTYET				if (!ok) continue;		// ???Risky!#else				if (!ok) return (NILINK);#endif			}			else if (layern==1)										/* If layer 1 (and layers 2-4) are empty, make whole-meas rest. */				insWholeMeasRest = TRUE;		}		if (insWholeMeasRest) {			voice = staffn;											/* default voice for this staff */			ok = FIInsertWholeMeasRest(doc, doc->tailL, staffn, voice, TRUE);			if (!ok) return (NILINK);		}	}#else	for (layern = 1; layern<=NUMLAYERS; layern++) {		for (staffn = 1; staffn<=doc->nstaves; staffn++) {			frameL = GetETFFrameL(staffn, measn, layern);			if (frameL==NoGood) return (NILINK);			if (frameL) {				ok = ConvertFrame(doc, layern, staffn, frameL, firstMeasOfSystem);				if (!ok) return (NILINK);			}			else if (layern==1) {				voice = staffn;											/* default voice for this staff */				ok = FIInsertWholeMeasRest(doc, doc->tailL, staffn, voice, TRUE);				if (!ok) return (NILINK);			}		}	}#endif	/* Insert barline to terminate this measure. */	barlineType = BAR_SINGLE;			// ??for now. Later: GetETFBarlineType(); ETF2NightBarlineType();	measL = FIInsertBarline(doc, doc->tailL, barlineType);	return (measL);}/* ------------------------------------------------------------- CheckKeysigChange -- *//* Check for a change of key signature at the beginning of this measure, and create oneif necessary. Assume that if the top staff's key sig. has changed in this meas, thenkey sigs on all staves have changed. Returns TRUE if ok, FALSE if error.NB: We do *not* yet support key sig. changes on only some staves in a meas. */static Boolean CheckKeysigChange(Document *doc, short measn, Boolean firstMeasOfSystem){	short				staffn, keySig, prevKeySig, thisKeySig, sharpsOrFlats;	LINK				sysL, insertBeforeL, newKSL;	Boolean			ok;	if (measn<=1) return FALSE;					/* We don't handle initial key sig. of score here. */		ok = GetETFKeySig(measn, 1, &keySig);	if (!ok) goto broken;	ok = GetETFKeySig(measn-1, 1, &prevKeySig);	if (!ok) goto broken;		if (keySig!=prevKeySig) {		/* First create one keysig object with subobjects for each staff.		 * All will have the same keysig.		 */		sharpsOrFlats = ETFtoNightKeysig(keySig);		if (firstMeasOfSystem) {			sysL = LSSearch(doc->tailL, SYSTEMtype, ANYONE, GO_LEFT, FALSE);			if (sysL==NILINK) goto broken;			if (FirstSysInPage(sysL))				insertBeforeL = LSSearch(sysL, PAGEtype, ANYONE, GO_LEFT, FALSE);			else				insertBeforeL = sysL;		}		else			insertBeforeL = doc->tailL;		doc->selEndL = doc->selStartL = insertBeforeL;		NewKeySig(doc, 0, sharpsOrFlats, ANYONE);		newKSL = LSSearch(insertBeforeL, KEYSIGtype, ANYONE, GO_LEFT, FALSE);		/* Now fix up the keysig for each staff whose keysig differs from that of the first		 * staff (probably because either of those staves is for a transposing instrument).		 */		for (staffn = 2; staffn<=doc->nstaves; staffn++) {			ok = GetETFKeySig(measn, staffn, &thisKeySig);			if (!ok) goto broken;			if (thisKeySig!=keySig) {				ok = FIReplaceKeySig(doc, newKSL, staffn, sharpsOrFlats);				if (!ok) goto broken;				FixInitialKSxds(doc, newKSL, doc->tailL, staffn);			}		}	}	return TRUE;broken:	MayErrMsg("CheckKeysigChange: error converting key signature in measure %d", measn);	return FALSE;}/* ------------------------------------------------------------ CheckTimesigChange -- *//* Check for a change of time signature at the beginning of this measure, and createone if necessary. Assume that all the staves change to the same time signature.Returns TRUE if ok, FALSE if error.NB: We do *not* yet support time sig. changes on only some staves in a meas. */static Boolean CheckTimesigChange(Document *doc, short measn, Boolean firstMeasOfSystem){	short				timeSigNum, timeSigDenom, prevTimeSigNum, prevTimeSigDenom,						nightNum, nightDenom;	LINK				sysL, insertBeforeL;	Boolean			ok, isCompound;	if (measn<=1) return FALSE;								/* We don't handle initial time sig. of score here. */		ok = GetETFTimeSig(measn, ANYONE, &timeSigNum, &timeSigDenom);	if (!ok) goto broken;	ok = GetETFTimeSig(measn-1, ANYONE, &prevTimeSigNum, &prevTimeSigDenom);	if (!ok) goto broken;	if (timeSigNum!=prevTimeSigNum || timeSigDenom!=prevTimeSigDenom) {		ok = ETF2NightTimeSig(timeSigNum, timeSigDenom, &nightNum, &nightDenom, &isCompound);		if (!ok) goto broken;		doc->selEndL = doc->selStartL = doc->tailL;		NewTimeSig(doc, 0, ' ', ANYONE, N_OVER_D, nightNum, nightDenom);		if (firstMeasOfSystem) {										/* also insert courtesy time sig. at end of prev. system */			sysL = LSSearch(doc->tailL, SYSTEMtype, ANYONE, GO_LEFT, FALSE);			if (sysL==NILINK) goto broken;			if (FirstSysInPage(sysL))				insertBeforeL = LSSearch(sysL, PAGEtype, ANYONE, GO_LEFT, FALSE);			else				insertBeforeL = sysL;			doc->selEndL = doc->selStartL = insertBeforeL;			NewTimeSig(doc, 0, ' ', ANYONE, N_OVER_D, nightNum, nightDenom);		}	}	return TRUE;broken:	MayErrMsg("CheckTimesigChange: error converting time signature in measure %d", measn);	return FALSE;}/* --------------------------------------------------------------- CheckClefChange -- *//* Check for a change of clef just before the Enigma entry <entryL>, and createone if necessary. If the entry is at the beginning of the measure (startTimeis zero), insert the clef change before the barline, or before the system,if this is the first measure of a system (other than the first system).Returns TRUE if ok, FALSE if error.Assumes that this is NOT the first measure of the first system.Caller must call CheckClefChange once with startTime==0 before callingit again with startTimes greater than zero for the same staff and measure.(This is so that CheckClefChange can correctly maintain its prevClef static var.) */ static Boolean CheckClefChange(Document	*doc,										short			entryL,										FASTFLOAT	startTime,										short			staffn,										Boolean		firstMeasOfSystem){	short				nightClefType;	LINK				measL, insertBeforeL, clefL;	char				currClef;	Boolean			small;	CONTEXT			context;	static char		prevClef = ETFCLEF_TREB;	currClef = GetETFClef(entryL, startTime);	if (currClef==ETFCLEF_BADCLEF) goto broken;	nightClefType = ETF2NightClef(currClef);	small = TRUE;															// ??later do this right: get from gETF.pClefs[]		if (startTime==(FASTFLOAT)0) {									/* Insert a clef change BEFORE this measure. */		measL = LSSearch(doc->tailL, MEASUREtype, ANYONE, GO_LEFT, FALSE);		GetContext(doc, measL, staffn, &context);		if (context.clefType!=nightClefType) {			if (firstMeasOfSystem)										/* Insert before final barline of prev. system. */				insertBeforeL = LSSearch(LeftLINK(measL), MEASUREtype, ANYONE, GO_LEFT, FALSE);			else				insertBeforeL = measL;			clefL = FIInsertClef(doc, staffn, insertBeforeL, nightClefType, small);			if (clefL==NILINK) return FALSE;			FixContextForClef(doc, RightLINK(clefL), staffn, context.clefType, nightClefType);//say("Clef change before entry %d, clef=%d\n", entryL, currClef);		}		prevClef = currClef;												/* to detect clef changes during later calls within this measure */	}																			/*   (NB: do this even if NOT inserting a clef before this meas!) */	else if (currClef!=prevClef) {									/* Add a clef change in the middle of the measure. */		insertBeforeL = doc->tailL;		clefL = FIInsertClef(doc, staffn, insertBeforeL, nightClefType, small);		if (clefL==NILINK) return FALSE;		prevClef = currClef;												/* to detect clef changes during later calls within this measure *///say("Clef change: clef=%d, before entry %d at time=%d\n", currClef, entryL, (short)startTime);	}	return TRUE;broken:	MayErrMsg("CheckClefChange: error converting clef change before entry %d", entryL);	return FALSE;}/* ------------------------------------------------------------------- CheckTuplet -- *//* Checks the current Enigma entry <entryL> for tuplet membership. If the entry starts a tuplet, creates a Nightingale tuplet object with the requisite number of subobjects (i.e., tupleted notes). If it doesn't start a tuplet, but is amember of a tuplet already in progress, adjusts <entryETFdur> to take intoaccount the effect of the tuplet on the note's logical duration. (This enablesthe caller to keep track of elapsed duration within the measure.) If thecurrent entry is not part of a tuplet, does nothing.Returns TRUE if ok, FALSE if error.Assumes that when called with *tupletInProgress==TRUE, a previous call hascorrectly assigned the static variables tupleNum and tupleDenom!WARNING: Currently the following two conditions are NOT considered errors: 1) if a note claims to start a tuplet, but no Enigma tuplet record begins    with that note (see m. 17, cello part, of "RossTrio.etf") 2) if a note starts a tuplet while a tuplet is still in progress (that is,    it initiates a nested tuplet, which Nightingale cannot handle).We pretend that failure to create a tuplet in these two cases is not an error, sothat the conversion can continue. Hopefully, the worst that can happen is thatnotes in that voice in that measure will not have the right rhythm. The failureshouldn't result in illegal Nightingale objects. ??Perhaps something should bedone about this?NB: After creating the syncs in a measure, the caller should call FIFixTupletLinksto update the tpSync field in each tuplet subobject. */static Boolean CheckTuplet(Document			*doc,									short				staffn,									short				iVoice,				/* Ngale internal voice number */									short				entryL,				/* Current Enigma Entry (i.e., note/chord) link */									LINK				syncL,				/* Sync (NOT GRSync!) just created for current Enigma entry,																					or NILINK if caller doesn't want to create a tuplet object */									FASTFLOAT		*entryETFdur,									ETFTUPLEPARAM	*pTupleParam)		/* Caller must initialize pTupleParam->tupletInProgress to FALSE at start of function */{	short			tupletID, nInTuple, tupleNum, tupleDenom;	LINK			tupletL;	Boolean		ok, numVis, denomVis, brackVis, tupletInProgress;		nInTuple = pTupleParam->nInTuple;	tupleNum = pTupleParam->tupleNum;	tupleDenom = pTupleParam->tupleDenom;	tupletInProgress = pTupleParam->tupletInProgress;		if (gETF.pEntries[entryL].startTuplet) {		if (tupletInProgress)			return TRUE;													/* nested tuplet or bad startTuplet flag (see comment above) */			ok = GetETFTuplet(entryL, &tupletID);		if (!ok) return TRUE;				// ???returns TRUE now only because "RossTrio.etf" has spurious entry tupletstart flags!!				ok = ValidETFTuplet(tupletID);		if (!ok) return FALSE;				nInTuple = CountETFTupletEntries(tupletID);		if (nInTuple<2) return FALSE;		tupleNum = gETF.pTuplets[tupletID].accNum;		tupleDenom = gETF.pTuplets[tupletID].accDenom;		if (syncL) {			numVis = (gETF.pTuplets[tupletID].format!=ETFTUPLET_NOTHING);			denomVis = gETF.pTuplets[tupletID].useRatio;			brackVis = (gETF.pTuplets[tupletID].format==ETFTUPLET_NUMBRACKET ||							gETF.pTuplets[tupletID].format==ETFTUPLET_NUMSLUR);			tupletL = FICreateTUPLET(doc, iVoice, staffn, syncL, nInTuple,											tupleNum, tupleDenom, numVis, denomVis, brackVis);			if (tupletL==NILINK) goto broken;		}		tupletInProgress = TRUE;	}		if (tupletInProgress) {		*entryETFdur = (*entryETFdur * tupleDenom) / tupleNum;		/* NB: tupleDenom and tupleNum assigned in prev. call */		if (--nInTuple==0)			tupletInProgress = FALSE;	}	pTupleParam->nInTuple = nInTuple;	pTupleParam->tupleNum = tupleNum;	pTupleParam->tupleDenom = tupleDenom;	pTupleParam->tupletInProgress = tupletInProgress;	return TRUE;broken:	return FALSE;			// ???also should clean up pTupleParam}/* ------------------------------------------------------------------ ConvertFrame -- *//* ConvertFrame converts one measure of content in the given staff and layer from Enigma to Nightingale. It inserts the Nightingale objects before doc->tailL. It does *not* attempt to  sync these objects with objects on other staves; a higher level calls CompactVoices to do that. ConvertFrame assumes that the correct time and key signatures for the frame have already been placed in the Nightingale score, but it does set the initial clef, if necessary, and createsany clef changes required within the measure.Returns TRUE if ok, FALSE if error.In Finale, a "frame" is a non-empty measure on one staff in one layer. (A whole-measure restdoes not constitute a frame.) That measure may contain, at most, two voices, the second ofwhich is understood as being "launched" from a note in the first. To get more voices on astaff (or to make two voices in a way that is more intuitive), a user will create voicesin separate layers. But as of Finale 3.2, the transcription machinery prefers to use theolder "launch voice two" approach, so many Finale scores have two voices intertwined withina single frame. */static Boolean ConvertFrame(Document *doc, short layern, short staffn, short frameL,										Boolean firstMeasOfSystem){	short				thisEL, firstEL, lastEL, iVoice1, iVoice2, staffID, numNotes, remainder,						lDur, ndots, numV1Entries, numV2Entries, sTimeIndex, xOffset;	FASTFLOAT		startTime, entryETFDur, *v1startTimes = (FASTFLOAT *)NIL;	LINK				syncL, startL;	Boolean			ok, isGrace, inVoice2;	ETFTUPLEPARAM	v1TupleParam;		ok = CountEntriesInFrame(frameL, &numV1Entries, &numV2Entries);	if (!ok || (numV1Entries==0 && numV2Entries==0)) goto errComplain;		if (numV2Entries>0) {		v1startTimes = (FASTFLOAT *) NewPtr((Size) ((numV1Entries) * sizeof(FASTFLOAT)) );		if (!GoodNewPtr((Ptr)v1startTimes)) {			NoMoreMemory();			return FALSE;		}	}	staffID = GetETFStaffID(staffn);	iVoice1 = gETF.pStaves[staffID].v1NgIvoices[layern-1];	iVoice2 = gETF.pStaves[staffID].v2NgIvoices[layern-1];		v1TupleParam.tupletInProgress = FALSE;	startTime = (FASTFLOAT) 0;								/* NB: must be a float to avoid wrong clef changes inside tuplets, due to roundoff error */	lastEL = gETF.pFrames[frameL].lastL;	firstEL = gETF.pFrames[frameL].firstL;	sTimeIndex = 0;		for (thisEL = firstEL; thisEL; thisEL = gETF.pEntries[thisEL].nextL) {		if (layern==1) {				// ???Is it right to exclude other layers?			ok = CheckClefChange(doc, thisEL, startTime, staffn, firstMeasOfSystem);			if (!ok) goto errComplain;		}				if (gETF.pEntries[thisEL].legality==FALSE) break;		/* Don't continue converting this frame. */				if (gETF.pEntries[thisEL].inVoice2) {						/* Ignore during this loop. */			if (thisEL==lastEL) break;									/* Don't go to next frame! */			else continue;		}				remainder = ETF2NightDur(gETF.pEntries[thisEL].dur, &lDur, &ndots);		if (remainder==-1) goto errComplain;						/* too small or large to represent w/ CMN */																				/* else just ignore remainder */		entryETFDur = (FASTFLOAT) gETF.pEntries[thisEL].dur;		isGrace = gETF.pEntries[thisEL].isGrace;		numNotes = CountETFChord(thisEL);		if (isGrace)			syncL = FIInsertGRSync(doc, doc->tailL, numNotes);		else			syncL = FIInsertSync(doc, doc->tailL, numNotes);		if (syncL==NILINK) goto err;				if (!isGrace) {			ok = CheckTuplet(doc, staffn, iVoice1, thisEL, syncL, &entryETFDur, &v1TupleParam);			if (!ok) goto errComplain;		}				xOffset = gETF.pEntries[thisEL].xOffset;		ok = ConvertEntryNotes(doc, syncL, staffn, iVoice1, thisEL, lDur, ndots, startTime, xOffset);		if (!ok) goto err;				if (numV2Entries>0)			v1startTimes[sTimeIndex++] = startTime;		if (!isGrace)			startTime += entryETFDur;				if (thisEL==lastEL) break;										/* Don't go to next frame! */	}	/* If there are any notes in Enigma Voice 2, traverse this frame's entries again, this 	 * time creating Nightingale syncs to hold notes in Voice 2. Since V2 may contain gaps, 	 * also create "placeholder" rests to fill the gaps. Later DeleteAllPlaceholderRests 	 * will remove them. These rests are necessary, because without them CompactVoices 	 * would remove all gaps in Voice 2.	 */	if (numV2Entries>0) {		short				remainingV2Entries = numV2Entries;		Boolean			launchesV2, v2NoteInProgress = FALSE;		FASTFLOAT		prevV2endTime, placeholderRestDur;		ETFTUPLEPARAM	v2TupleParam;		#ifdef NOTYET		doc->voiceTab[iVoice2].voiceRole = LOWER_DI;#endif				startTime = prevV2endTime = placeholderRestDur = entryETFDur = (FASTFLOAT) 0;		v2TupleParam.tupletInProgress = v1TupleParam.tupletInProgress = FALSE;		sTimeIndex = 0;		for (thisEL = firstEL; thisEL; thisEL = gETF.pEntries[thisEL].nextL) {				if (gETF.pEntries[thisEL].legality==FALSE) break;				/* Don't continue converting this frame. */			if (!remainingV2Entries) break;										/* no need to keep inserting placeholder rests */			remainder = ETF2NightDur(gETF.pEntries[thisEL].dur, &lDur, &ndots);			if (remainder==-1) goto errComplain;								/* too small or large to represent w/ CMN */																							/* else just ignore remainder */			entryETFDur = (FASTFLOAT) gETF.pEntries[thisEL].dur;			isGrace = gETF.pEntries[thisEL].isGrace;			inVoice2 = gETF.pEntries[thisEL].inVoice2;			launchesV2 = gETF.pEntries[thisEL].launchesVoice2;	#ifdef ECDEBUGsay("Voice %d: stf=%d\tframe=%d \t entry=%d \t time=%d \t dur=%d \t %s\n",			inVoice2? 2 : 1, staffn, frameL, thisEL,			(short)startTime, (short)entryETFDur, launchesV2? "launchesV2" : "");#endif			if (inVoice2) {				remainingV2Entries--;				v2NoteInProgress = TRUE;								/* Before inserting this V2 note, insert placeholder rest(s) to fill any preceding gap. */				if (placeholderRestDur) {					ok = InsertPlaceholderRest(doc, doc->tailL, staffn, iVoice2, (short)placeholderRestDur);					if (!ok) goto errComplain;					startTime += placeholderRestDur;					placeholderRestDur = (FASTFLOAT) 0;				}			}			else {				if (v2NoteInProgress && v1startTimes[sTimeIndex]>=prevV2endTime)					v2NoteInProgress = FALSE;				sTimeIndex++;				if (!launchesV2 && !v2NoteInProgress && !isGrace) {					ok = CheckTuplet(doc, staffn, iVoice1, thisEL, NILINK, &entryETFDur, &v1TupleParam);					if (!ok) goto errComplain;					placeholderRestDur += entryETFDur;					/* Accumulate until we hit a voice 2 note */				}				if (thisEL==lastEL) break;									/* Don't go to next frame! */				continue;														/* Don't convert voice 1 notes twice! */			}						numNotes = CountETFChord(thisEL);			if (isGrace)				syncL = FIInsertGRSync(doc, doc->tailL, numNotes);			else				syncL = FIInsertSync(doc, doc->tailL, numNotes);			if (syncL==NILINK) goto err;						if (!isGrace) {				ok = CheckTuplet(doc, staffn, iVoice2, thisEL, syncL, &entryETFDur, &v2TupleParam);				if (!ok) goto errComplain;			}						xOffset = gETF.pEntries[thisEL].xOffset;			ok = ConvertEntryNotes(doc, syncL, staffn, iVoice2, thisEL, lDur, ndots, startTime, xOffset);			if (!ok) goto err;						prevV2endTime = startTime + entryETFDur;			if (!isGrace)				startTime += entryETFDur;				if (thisEL==lastEL) break;										/* Don't go to next frame! */		}	}	/* Fix up the tpSync fields for any tuplets. */	startL = LSSearch(doc->tailL, MEASUREtype, ANYONE, GO_LEFT, FALSE);	FIFixTupletLinks(doc, startL, doc->tailL, iVoice1);	if (numV2Entries>0)		FIFixTupletLinks(doc, startL, doc->tailL, iVoice2);			if (v1startTimes) DisposePtr((char *)v1startTimes);	return TRUE;	errComplain:	MayErrMsg("ConvertFrame: error converting frame %d, on staff %d in layer %d", frameL, staffn, layern);err:	if (v1startTimes) DisposePtr((char *)v1startTimes);	return FALSE;}/* ------------------------------------------------------------- ConvertEntryNotes -- *//* Given information about an Enigma note or chord and a Nightingale sync created forit, fill in the fields of the individual note subobjects. All the notes of the chordare in the same voice on the same staff. The caller should have created the syncwith exactly the number of subobjects required for it by this Enigma voice. (Thesync will contain subobjects only in this voice.) Returns TRUE if ok, FALSE if error. */static Boolean ConvertEntryNotes(Document		*doc,											LINK			syncL,											short			staffn,											short			iVoice,				/* Ngale internal voice number */											short			entryL,				/* index into array of Enigma entries */											short			lDur,											short			ndots,											FASTFLOAT	startTime,			/* in EDU's */											short			xOffset)				/* in EVPU's (neg. numbers move note to left of sync) */{	short			numNotes, thisNL, halfLn, accident;	char			ksAccident, raiseLower;	SignedByte	myAccTable[MAX_STAFFPOS];	LINK			aNoteL;	PANOTE		aNote;	Boolean		ok, isRest, isGrace;	CONTEXT		context;	isRest = gETF.pEntries[entryL].isRest;	isGrace = gETF.pEntries[entryL].isGrace;	/* Init. a local version of the global accTable (an accidental/pitch modification table	 * by staff ln/space) from the current key sig. Must use a local version because SetupNote	 * initializes accTable in a way that will screw up interpretation of ETF accidentals.	 * (See explanation below.)	 */	GetContext(doc, LeftLINK(syncL), staffn, &context);	KeySig2AccTable(myAccTable, (PKSINFO)context.KSItem);	aNoteL = FirstSubLINK(syncL);		for (thisNL = gETF.pEntries[entryL].firstNoteL, numNotes = 0; thisNL;									thisNL = gETF.pNotes[thisNL].nextL, numNotes++) {		/* Finale raiseLower accidental value is relative to accidentals in the current		 * key signature, not to accidentals affecting the same half-line earlier in the		 * measure. So, for example, if a voice in E major has [Bb B#], Finale will		 * encode the accidentals of the two notes as [lower1semitone raise1semitone],		 * NOT as [lower1semitone raise2semitones]. The B# is raised 1 semitone relative		 * to the B natural given by the keysig, not to the Bb earlier in the measure.		 */		halfLn = ETF2NightHalfLn(entryL, thisNL, startTime, MIDDLEC_REL_HALFLN);		ksAccident = myAccTable[halfLn+ACCTABLE_OFF];		if (ksAccident==0) ksAccident = AC_NATURAL;		raiseLower = GetETFRaiseLowerAcc(thisNL);		accident = ksAccident + raiseLower;				/* Now get the staff-relative half-line that SetupNote expects. */		halfLn = ETF2NightHalfLn(entryL, thisNL, startTime, STAFF_REL_HALFLN);		if (isGrace) {			SetupGRNote(doc, syncL, aNoteL, staffn, halfLn,						lDur, ndots, iVoice, accident, 0);			if (!gETF.pNotes[thisNL].hasAcc) GRNoteACC(aNoteL) = 0;			aNoteL = NextGRNOTEL(aNoteL);		}		else {			SetupNote(doc, syncL, aNoteL, staffn, halfLn,						lDur, ndots, iVoice, isRest, accident, 0);			aNote = GetPANOTE(aNoteL);			if (!gETF.pNotes[thisNL].hasAcc)				aNote->accident = 0;			aNote->tiedR = gETF.pNotes[thisNL].tiedR;						/* flag for subsequent call to CreateAllTies */			aNote->tiedL = gETF.pNotes[thisNL].tiedL;#ifdef NOTYET			aNote->slurredR = gETF.pNotes[thisNL].slurredR;				/* flag for subsequent call to CreateAllSlurs */			aNote->slurredL = gETF.pNotes[thisNL].slurredL;#endif			if (xOffset)				aNote->xd = evpu2d(xOffset, context.staffHeight);			aNoteL = NextNOTEL(aNoteL);		}	}		if (numNotes>1) {		if (isGrace)			ok = FixGRSyncForChord(doc, syncL, iVoice, 0/*beamed*/, 0, 0, NULL);		else			ok = FixSyncForChord(doc, syncL, iVoice, 0/*beamed*/, 0, 0, NULL);	}	return TRUE;broken:	MayErrMsg("ConvertEntryNotes: error converting entry %d in voice %d on staff %d", entryL, iVoice, staffn);	return FALSE;}/* --------------------------------------------------------- InsertPlaceholderRest -- *//* Insert a placeholder rest before <insertBeforeL> on the given staff in the given(internal) voice. Does NOT attempt to create a sync with notes on other staves.Returns TRUE if ok, FALSE if error. */#define UNLIKELY_REST_HEIGHT	127		/* type: SHORTQD */static Boolean InsertPlaceholderRest(Document *doc, LINK insertBeforeL, short staffn,													short iVoice, short restETFdur){	LINK		syncL, aNoteL;	short		lDur, ndots, remainder;	for (remainder = restETFdur; remainder>0; ) {		remainder = ETF2NightDur(remainder, &lDur, &ndots);		if (remainder==-1) break;										/* too small or large to represent w/ CMN */		syncL = InsertNode(doc, insertBeforeL, SYNCtype, 1);		if (syncL==NILINK) {			NoMoreMemory();			return FALSE;		}		SetObject(syncL, 0, 0, TRUE, TRUE, FALSE);		LinkTWEAKED(syncL) = FALSE;		aNoteL = FirstSubLINK(syncL);		SetupNote(doc, syncL, aNoteL, staffn, -1/*halfLn*/, lDur, ndots, iVoice, TRUE, 0, 0);			/* Mark it so DeleteAllPlaceholderRests will recognize it. */	//	NoteAPPEAR(aNoteL) = SLASH_SHAPE; ???might want to use this later ... also in DeleteAllPlaceholderRests!		NoteYQPIT(aNoteL) = UNLIKELY_REST_HEIGHT;	}		return TRUE;broken:	MayErrMsg("InsertPlaceholderRest: error creating placeholder rest on staff %d", staffn);	return FALSE;}/* ----------------------------------------------------- DeleteAllPlaceholderRests -- */static Boolean DeleteAllPlaceholderRests(Document *doc){	LINK		pL, nextL, aNoteL, tempL;	PANOTE	aNote;		pL = doc->headL;	while (pL!=doc->tailL) {		nextL = RightLINK(pL);													/* Save this now, since we might delete pL below. */		if (SyncTYPE(pL)) {			aNoteL = FirstSubLINK(pL);			while (aNoteL) {				tempL = NextNOTEL(aNoteL);										/* Save this now, since we might delete aNoteL below. */				aNote = GetPANOTE(aNoteL);				if (aNote->rest && aNote->yqpit==UNLIKELY_REST_HEIGHT) {#ifdef NOTYET					if (aNote->inTuplet)						DelTupletForSync(doc, pL, aNoteL);#endif					LinkNENTRIES(pL)--;					if (!LinkNENTRIES(pL))										/* If it's the only subobject in its sync, */						DeleteNode(doc, pL);										/*   delete entire sync. CAUTION: pL no longer valid! */					else {															/* Else delete just this rest subobject. */						RemoveLink(pL, NOTEheap, FirstSubLINK(pL), aNoteL);						HeapFree(NOTEheap, aNoteL);							/* CAUTION: aNoteL no longer valid! */					}				}				aNoteL = tempL;			}		}				pL = nextL;	}	return TRUE;broken:	MayErrMsg("DeleteAllPlaceholderRests: error deleting placeholder rest (sync=%d, note=%d).", pL, aNoteL);	return FALSE;}/* ------------------------------------------------------------ OptimizeAllSystems -- *//* Hide every staff that the Enigma file records as hidden (because the user has askedFinale to "optimize" the system containing the staff). Return TRUE if ok, FALSE iferror. */static Boolean OptimizeAllSystems(Document *doc){	short		i, j;	LINK		pL, staffL, aStaffL;	Boolean	foundStaff;		if (gNumOptimizedStaves==0 || gNumSystems<1) return TRUE;			/* No systems are optimized. */			for (i = 1; i<=gNumSystems; i++)		for (pL = doc->headL; pL!=doc->tailL; pL = RightLINK(pL))			if (SystemTYPE(pL) && SystemNUM(pL)==i) {				staffL = LSSearch(pL, STAFFtype, ANYONE, GO_RIGHT, FALSE);				if (staffL==NILINK) goto broken;				foundStaff = FALSE;				for (j = 1; j<=doc->nstaves; j++)					if (!StaffIsVisible(i, j))						for (aStaffL = FirstSubLINK(staffL); aStaffL; aStaffL = NextSTAFFL(aStaffL))							if (StaffSTAFF(aStaffL)==j) {								LinkSEL(staffL) = StaffSEL(aStaffL) = TRUE;	/* Select the staff. */								foundStaff = TRUE;								break;							}				if (foundStaff==TRUE) {					doc->selStartL = staffL;					doc->selEndL = RightLINK(staffL);					InvisifySelStaves(doc);					DeselRangeNoHilite(doc, staffL, RightLINK(staffL));				}			}		return TRUE;broken:	MayErrMsg("OptimizeAllSystems failed!");	return FALSE;}/* ---------------------------------------------------------------------------------- *//* Functions for creating and displaying the converted ETF document. *//* --------------------------------------------------------- CountStavesInETFGroup -- *//* Return the number of Enigma staves in use that have the same group number.NB: the staves do NOT have to be adjacent. The caller should be aware thatstaves that are not in any group have a group number equal to zero. If thecaller calls CountStavesInETFGroup with groupNum==0, this function returnsthe number of staves in use that are NOT in any group. */static short CountStavesInETFGroup(short groupNum){	short	i, count = 0;		for (i = 1; i<=gNumStaves; i++) {		if (gETF.pStaves[i].staffNum==0)			continue;															/* staff not in use */		if (gETF.pStaves[i].group==groupNum)			count++;	}	return (count);}/* -------------------------------------------------------------- Likely2StaffPart -- *//* Given an Enigma group number, return TRUE if staves that have that group numbershould become one part of two staves in Nightingale. The criteria are:  <groupNum> must be greater than 0,  the group must be assigned to exactly two adjacent staves in use,   the group has at least one connect, and  that connect is of type ETFCONNECT_CURLY.If any of these conditions is not met, return FALSE. */ static Boolean Likely2StaffPart(short groupNum){	short	count, i, staffn;		if (groupNum<1) return FALSE;	count = CountStavesInETFGroup(groupNum);	if (count!=2) return FALSE;		for (i = 1, staffn = 0; i<=gNumStaves; i++) {		if (gETF.pStaves[i].staffNum==0)			continue;																	/* staff not in use */		if (gETF.pStaves[i].group==groupNum) {			if (staffn==0)				staffn = gETF.pStaves[i].staffNum;			else				if (ABS(staffn-gETF.pStaves[i].staffNum) != 1)					return FALSE;		}	}		/* (Note that it is possible for a group to have more than one connect. We stupidly	 * examine only the first connect we find that has the right group number.)	 */	for (i = 1; i<=gNumConnects; i++)		if (gETF.pConnects[i].group==groupNum && gETF.pConnects[i].type==ETFCONNECT_CURLY)			return TRUE;	return FALSE;}/* ----------------------------------------------------------------- SetupETFscore -- */static short SetupETFscore(Document *doc){	char			clefType;	Boolean		ok, isCompound;	short			staffID, staffn, nStaves, sharpsOrFlats, ETFkeysig,					timeSigNum, timeSigDenom, nightNum, nightDenom, showLines;	LINK			prevL=NILINK, pageL=NILINK, sysL=NILINK, connL=NILINK,					firstClefL, partL, prevPartL, firstTSL, firstKeySigL, endL;	DDIST			sysTop=0,spBefore=0;	PPARTINFO	pPart;	InstallDoc(doc);		/* We now have a default score with one part of two staves. Set it up	 * according to the ETF file structure, and then remove the default part.	 */	for (staffn = 1; staffn<=gNumStavesUsed; staffn+=nStaves) {		staffID = GetETFStaffID(staffn);		if (staffID==NoGood) {			MayErrMsg("SetupETFscore: no staff record for this staffNum! (staffn=%d)\n", staffn);			return (NoGood);		}		nStaves = (Likely2StaffPart(gETF.pStaves[staffID].group))? 2 : 1;		if (gETF.pStaves[staffID].numLines==0 || gETF.pStaves[staffID].numLines==1)			showLines = gETF.pStaves[staffID].numLines;		else			showLines = SHOW_ALL_LINES;		partL = AddPart(doc, 2+(staffn-1), nStaves, showLines);		if (partL==NILINK) return (NoGood);		InitPart(partL, 2+staffn, 2+staffn+(nStaves-1));	}	/* Remove default 2-staff part. Must do this before changing attributes below... */	DeletePart(doc, 1, 2);// ??Is this the place to fiddle with rastral, space btw. staves, pg size, etc.//	to get everything to fit on one page?// See FitStavesOnPaper in MIDIFOpen.c	/* Set up remaining parts with ETF attributes, including initial clefs & keysigs. */			firstClefL = LSSearch(doc->headL, CLEFtype, 1, GO_RIGHT, FALSE);	if (firstClefL==NILINK) {		MayErrMsg("SetupETFscore: can't find 1st clef!\n");		return (NoGood);	}	firstKeySigL = LSSearch(doc->headL, KEYSIGtype, 1, GO_RIGHT, FALSE);	if (firstKeySigL==NILINK) {		MayErrMsg("SetupETFscore: can't find 1st keysig!\n");		return (NoGood);	}	prevPartL = NILINK;	for (staffn = 1; staffn<=gNumStavesUsed; staffn++) {		staffID = GetETFStaffID(staffn);		if (staffID==NoGood) {			MayErrMsg("SetupETFscore: no ETF staff record for this staffNum! (staffn=%d)\n", staffn);			return (NoGood);		}		/* Set up part info. */		partL = FindPartInfo(doc, Staff2Part(doc, staffn));		if (partL==NILINK) return (NoGood);		if (partL!=prevPartL) {										/* Get names from 1st staff of multi-staff part. */			pPart = GetPPARTINFO(partL);			strcpy(pPart->name, gETF.pStaves[staffID].fullname);			strcpy(pPart->shortName, gETF.pStaves[staffID].abrevname);			prevPartL = partL;		}				/* Set initial clef. */		clefType = ETF2NightClef(gETF.pStaves[staffID].startClef);		if (clefType==-1) return (NoGood);		ReplaceClef(doc, firstClefL, staffn, clefType);				/* Set inital keysig, taking into account transposing instruments. */		// ???should change values in the part for transposing MIDI note nums???		ok = GetETFKeySig(1, staffn, &ETFkeysig);		if (!ok) return (NoGood);		sharpsOrFlats = ETFtoNightKeysig(ETFkeysig);		endL = ReplaceKeySig(doc, firstKeySigL, staffn, sharpsOrFlats);		/* Fix horizontal space taken by key sigs. */		FixInitialKSxds(doc, firstKeySigL, doc->tailL/*endL*/, staffn);	}	DeselectNode(firstClefL);						/* or else initial clefs will remain hilited & selected */	/* Set up initial timesig, for now just using the top staff's timesig for all staves. */	if (gNumMeas>0) {									/* Seems to be more reliable to get this from first meas than from staff obj. */		timeSigNum = gETF.pMeasures[1].timeSigNum;		timeSigDenom = gETF.pMeasures[1].timeSigDenom;	}	else {		timeSigNum = gETF.pStaves[1].timeSigNum;		timeSigDenom = gETF.pStaves[1].timeSigDenom;	}	ok = ETF2NightTimeSig(timeSigNum, timeSigDenom, &nightNum, &nightDenom, &isCompound);	if (!ok) return (NoGood);	firstTSL = LSSearch(doc->headL, TIMESIGtype, 1, GO_RIGHT, FALSE);	if (firstTSL==NILINK) {		MayErrMsg("SetupETFscore: can't find 1st time sig!\n");		return (NoGood);	}	ReplaceTimeSig(doc, firstTSL, ANYONE/*staffn*/, N_OVER_D, nightNum, nightDenom);		FixMeasRectYs(doc, NILINK, TRUE, TRUE, FALSE);				/* Fix measure & system tops & bottoms */	Score2MasterPage(doc);	sysTop = SYS_TOP(doc)+pt2d(config.titleMargin);	doc->yBetweenSys = 0;	return (0);}/* ------------------------------------------------------------------ CreateETFdoc -- */#define ETF_RASTRAL 1						/* equivalent to 100% staff size in Finale */static Document *CreateETFdoc(unsigned char *fileName){	register Document		*newDoc = NULL;	WindowPtr				w;	short						rastral;	long						fileVersion;	newDoc = FirstFreeDocument();	if (newDoc==NULL) {		TooManyDocs(); return (NULL);	}		w = GetNewWindow(docWindowID, NULL, BottomPalette);	if (!w) return (NULL);	newDoc->theWindow = w;	SetDocumentKind(w);	//((WindowPeek)w)->spareFlag = TRUE;	ChangeWindowAttributes(w, kWindowFullZoomAttribute, kWindowNoAttributes);		newDoc->inUse = TRUE;	Pstrcpy(newDoc->name, fileName);	newDoc->vrefnum = 0;		/* Create newDoc, the document for the converted ETF score. */		rastral = GetETFRastral(gETF.pPages[1].sizePct, 100, 100);	if (!BuildETFdoc(newDoc, &fileVersion, 0/*pageWidth*/, 0/*pageHt*/, gNumStavesUsed, rastral)) {		DoCloseDocument(newDoc);		return (NULL);	}	return (newDoc);}#define UnusedArg(arg)	(arg);	/* To avoid warnings about unused arguments, I guess. -DB *//* ------------------------------------------------------------------- BuildETFdoc -- *//* Initialise a new Document, untitled and empty. Make the Document the currentgrafPort and install it, including magnification. Return TRUE normally, FALSE incase of error. */static Boolean BuildETFdoc(						Document *doc,						long *fileVersion,						short /*pageWidth*/,						short /*pageHt*/,						short nStaves,						short rastral){	WindowPtr		w = doc->theWindow;	Rect				r;	UnusedArg(nStaves)	SetPort(GetWindowPort(w));		/* Set the initial paper size, margins, etc. */		doc->paperRect.top = doc->paperRect.left = 0;		// ???Assume that 1st page of Finale score is same size as all of them.	// ???Should look at page sizes available w/ current printer?	// And choose correct one in pg setup, etc...	doc->paperRect.bottom = gETF.pPages[1].height/4;					/* Enigma sizes are in 1/4 pts. */	doc->paperRect.right = gETF.pPages[1].width/4;		doc->pageType = 2;		// ???Is this even used?	doc->measSystem = 0;	doc->origPaperRect = doc->paperRect;	/* Enigma page margins work like this: Top and right are distance of margin	 * from top and right of page, expressed as a negative number of EVPU's	 * (1/4 pts). Left and bottom are distance from left and bottom of page,	 * expressed as a positive number of EVPU's.	 */	doc->marginRect.top = doc->paperRect.top + -(gETF.pPages[1].margins.top/4);	doc->marginRect.left = doc->paperRect.left + (gETF.pPages[1].margins.left/4);	doc->marginRect.bottom = doc->paperRect.bottom - (gETF.pPages[1].margins.bottom/4);	doc->marginRect.right = doc->paperRect.right - -(gETF.pPages[1].margins.right/4);	InitDocFields(doc);	doc->srastral = rastral;								/* Override staff size, from parameter */	FillSpaceMap(doc, 0);	/* Add the standard scroll bar controls to Document's window. The scroll	 *	bars are created with a maximum value of 0 here, but this will have no	 *	effect if we call RecomputeView, since it resets the max.	 */	GetWindowPortBounds(w,&r);	r.left = r.right - (SCROLLBAR_WIDTH+1);	r.bottom -= SCROLLBAR_WIDTH;	r.top--;		doc->vScroll = NewControl(w, &r, "\p", TRUE, doc->origin.h, doc->origin.h, 0, scrollBarProc, 0L);	GetWindowPortBounds(w,&r);	r.top = r.bottom - (SCROLLBAR_WIDTH+1);	r.right -= SCROLLBAR_WIDTH;	r.left += MESSAGEBOX_WIDTH;		doc->hScroll = NewControl(w, &r, "\p", TRUE, doc->origin.v, doc->origin.v, 0, scrollBarProc, 0L);	if (!InitAllHeaps(doc)) { NoMoreMemory(); return FALSE; }	InstallDoc(doc);	BuildEmptyList(doc, &doc->headL, &doc->tailL);		doc->selStartL = doc->selEndL = doc->tailL;			/* Empty selection  */		/* Set part name showing and corresponding system indents. We'd like to use	 * PartNameMargin() to get the appropriate indents, but not enough of the data	 * structure is set up, so do something cruder.	 */	doc->firstNames = FULLNAMES;								/* 1st system: full part names */	doc->firstIndent = qd2d(config.indent1st, drSize[doc->srastral], STFLINES);	doc->otherNames = NONAMES;									/* Other systems: no part names */	doc->otherIndent = 0;		*fileVersion = THIS_VERSION;	NewDocScore(doc);										/* Set up initial staves, clefs, etc. */	doc->firstSheet = 0;	doc->currentSheet = 0;	doc->origin = doc->sheetOrigin;					/* Ignore position recorded in file */	if (useWhichMIDI==MIDIDR_FMS) {		/* These won't pop any alerts. */		(void)FMSCheckPartDestinations(doc, TRUE);		FMSSetNewDocRecordDevice(doc);	}	if (!InitDocUndo(doc))		return FALSE;		doc->yBetweenSysMP = doc->yBetweenSys = 0;	SetOrigin(doc->origin.h, doc->origin.v);	GetAllSheets(doc);	/* Finally, set empty selection just after the first Measure and put caret there.		N.B. This will not necessarily be on the screen! We should eventually make		the initial selection agree with the doc's scrolled position. */	SetDefaultSelection(doc);	doc->selStaff = 1;		MEAdjustCaret(doc, FALSE);		return TRUE;}/* ----------------------------------------------------------------- DisplayETFdoc -- *//* Set up and display the newly created ETF document. */static void DisplayETFdoc(Document *newDoc){	short				palWidth, palHeight;	Rect				box,bounds;	WindowPtr		w; 	/* Replace the Master Page: delete the old Master Page data structure		here and replace it with a new structure to reflect the part-staff		structure of the scanned score. */	// Score2MasterPage(newDoc); ???Why is this commented out?!	newDoc->docNew = newDoc->changed = TRUE;			/* Has to be set after BuildDocument */	newDoc->readOnly = FALSE;			/* Place new document window in a non-conflicting position */	w = newDoc->theWindow;		WindowPtr palPtr = (*paletteGlobals[TOOL_PALETTE])->paletteWindow;	GetWindowPortBounds(palPtr,&box);	palWidth = box.right - box.left;	palHeight = box.bottom - box.top;	GetGlobalPort(w,&box);								/* set bottom of window near screen bottom */	bounds = GetQDScreenBitsBounds();	if (box.left < bounds.left+4)		box.left = bounds.left+4;	if (palWidth < palHeight)		box.left += palWidth;	MoveWindow(newDoc->theWindow, box.left, box.top, FALSE);	AdjustWinPosition(w);	GetGlobalPort(w, &box);	bounds = GetQDScreenBitsBounds();	box.bottom = bounds.bottom - 4;	if (box.right > bounds.right-4)		box.right = bounds.right - 4;	SizeWindow(newDoc->theWindow, box.right-box.left, box.bottom-box.top, FALSE);	SetOrigin(newDoc->origin.h, newDoc->origin.v);	GetAllSheets(newDoc);	RecomputeView(newDoc);	SetControlValue(newDoc->hScroll, newDoc->origin.h);	SetControlValue(newDoc->vScroll, newDoc->origin.v);	SetWTitle(w, newDoc->name);		InstallMagnify(newDoc);	ShowDocument(newDoc);}/* ------------------------------------------------------------------ AssignVoices -- *//* Analyze the ETF data structure to determine how many voices each of itsstaves requires. Set up the Nightingale score's voice table to accommodatethese requirements, and store the Nightingale internal voice numbersin each of the ETF staff records. Assumes that the Nightingale documenthas already been set up with the same number of staves that the Enigmafile uses. Returns TRUE if ok, FALSE if error. */#define INUSE -1static Boolean AssignVoices(Document *doc){	short		i, j, staffID, staffn, layer, numV1Entries, numV2Entries, defaultVoice,				uVoice, iVoice;	LINK		partL;	Boolean	ok;			/* Analyze ETF voice requirements. Mark each required voice with INUSE. */	for (i=1; i<=gNumFrames; i++) {		staffID = gETF.pFrames[i].staffID;		layer = gETF.pFrames[i].layerNum;// ??? error check staff and layer		ok = CountEntriesInFrame(i, &numV1Entries, &numV2Entries);		if (!ok) goto broken;		if (numV1Entries)			gETF.pStaves[staffID].v1NgIvoices[layer-1] = INUSE;		if (numV2Entries)			gETF.pStaves[staffID].v2NgIvoices[layer-1] = INUSE;	}		/* Assign a Nightingale default voice to one of the voices in each ETF staff.	 * It's likely that the default voice will always correspond to ETF V1, layer 1,	 * but it's possible, for example, that an ETF staff could have notes in layer 2	 * but not in layer 1.	 */	for (i=1; i<=gNumStaves; i++) {		if (gETF.pStaves[i].staffNum==0)			continue;																	/* It's an unused staff. */		defaultVoice = gETF.pStaves[i].staffNum;								/* Ngale default voice */		if (gETF.pStaves[i].v1NgIvoices[0]==INUSE)			gETF.pStaves[i].v1NgIvoices[0] = defaultVoice;					/* most likely */		else if (gETF.pStaves[i].v2NgIvoices[0]==INUSE)			gETF.pStaves[i].v2NgIvoices[0] = defaultVoice;					/* else use V2 in layer 1 */		else {			for (j=1; j<NUMLAYERS; j++) {											/* else check other layers */				if (gETF.pStaves[i].v1NgIvoices[j]==INUSE) {					gETF.pStaves[i].v1NgIvoices[j] = defaultVoice;					break;				}				if (gETF.pStaves[i].v2NgIvoices[j]==INUSE) {					gETF.pStaves[i].v2NgIvoices[j] = defaultVoice;					break;				}			}		}	}		/* Create a new Nightingale voice for every voice NOT in the default voice for its staff.	 * Fill each ETF staff's v1NgIvoices and v2NgIvoices arrays with the correct Ngale internal	 * voice numbers.	 */	for (i=1; i<=gNumStaves; i++) {		if (gETF.pStaves[i].staffNum==0)			continue;																	/* It's an unused staff. */		staffn = gETF.pStaves[i].staffNum;		partL = FindPartInfo(doc, Staff2Part(doc, staffn));		for (j=0; j<NUMLAYERS; j++) {			if (gETF.pStaves[i].v1NgIvoices[j]==INUSE) {				uVoice = NewVoiceNum(doc, partL);				if (BADUSERVOICENUM(uVoice)) goto broken;				iVoice = User2IntVoice(doc, uVoice, partL);				if (iVoice==0) goto broken;				gETF.pStaves[i].v1NgIvoices[j] = iVoice;			}			if (gETF.pStaves[i].v2NgIvoices[j]==INUSE) {				uVoice = NewVoiceNum(doc, partL);				if (BADUSERVOICENUM(uVoice)) goto broken;				iVoice = User2IntVoice(doc, uVoice, partL);				if (iVoice==0) goto broken;				gETF.pStaves[i].v2NgIvoices[j] = iVoice;			}		}	}#ifdef ECDEBUG	/* Print voices */	for (i=1; i<=gNumStaves; i++)		if (gETF.pStaves[i].staffNum) {			say("StaffID %d, StaffNum %d.................\n", i, gETF.pStaves[i].staffNum);			for (j=1; j<=NUMLAYERS; j++) {				say("\tLayer %d, V1: iVoice=%d\n", j, gETF.pStaves[i].v1NgIvoices[j-1]);				say("\tLayer %d, V2: iVoice=%d\n", j, gETF.pStaves[i].v2NgIvoices[j-1]);			}		}#endif	return TRUE;broken:	MayErrMsg("AssignVoices failed");	// ??Can Enigma file have more than MAXVOICES voices?	return FALSE;}/* --------------------------------------------------------------------------------- *//* ETF searching functions *//* --------------------------------------------------------------- StaffIsVisible -- *//* Return TRUE if the given staff is visible on the given system, FALSE if it is notvisible (due to "optimization" of system).CAUTION: Assumes that systemNum and staffn refer to items in the data structure. */static Boolean StaffIsVisible(short systemNum, short staffn){	unsigned short	i;	short				staffID;	Boolean			sysIsOptimized;		if (gNumOptimizedStaves==0) return TRUE;								/* No systems are optimized. */		staffID = GetETFStaffID(staffn);	if (staffID==NoGood) return TRUE;													// ??not really satisfactory!		/* If the staff is hidden, it will NOT appear in the ^IU lines for its system. */	sysIsOptimized = FALSE;	for (i = 1; i<=gNumOptimizedStaves; i++)		if (gETF.pOptimizedStaves[i].systemNum==systemNum) {			sysIsOptimized = TRUE;			if (gETF.pOptimizedStaves[i].staffID==staffID)				return TRUE;		}	if (sysIsOptimized)		return FALSE;					/* System is optimized and staff did not appear in the ^IU lines. */	else		return TRUE;						/* System isn't optimized, so staff must be visible. */}/* ---------------------------------------------------------------- CountETFChord -- *//* Count the number of notes in the entry given by <entryL>. If more than 1, it'sa chord. */static short CountETFChord(short entryL){	register short	i, nL;		for (i = 0, nL = gETF.pEntries[entryL].firstNoteL; nL; i++, nL = gETF.pNotes[nL].nextL) ;	return (i);}/* -------------------------------------------------------- CountETFTupletEntries -- *//* Count the number of entries (notes/chords) in the tuplet given by <tupletID>,an index into the gETF.pTuplets array. Counts only entries that are in thesame Enigma voice as the first entry pointed to by the tuplet. If this functionreturns less than 2 as the number of entries, the caller should consider it an error. */static short CountETFTupletEntries(short tupletID){	Boolean	firstEntryInV2;	short		i, entryL, dur, accNum, numDurUnit,				untupledDur;						/* total EDU's of all notes in tuplet (i.e.,															their logical durations in EDU's) */		accNum = gETF.pTuplets[tupletID].accNum;	numDurUnit = gETF.pTuplets[tupletID].numDurUnit;	untupledDur = accNum * numDurUnit;	#if NOMORE	/* don't need this information for Ngale? */	accDenom = gETF.pTuplets[tupletID].accDenom;	denomDurUnit = gETF.pTuplets[tupletID].denomDurUnit;	tupledDur = accDenom * denomDurUnit;#endif		entryL = gETF.pTuplets[tupletID].entryL;							/* first note/chord in tuplet */	firstEntryInV2 = gETF.pEntries[entryL].inVoice2;				/* Is first entry of tuplet in Voice 2? */	for (i = 1, dur = 0; entryL; ) {		if (gETF.pEntries[entryL].inVoice2==firstEntryInV2) {		/* If this entry in same voice as 1st entry...*/			dur += gETF.pEntries[entryL].dur;			if (dur==untupledDur)				return (i);			else if (dur>untupledDur)				return (0);														/* an error */			i++;																	/* only increment if in same voice */		}		entryL = gETF.pEntries[entryL].nextL;	}	return (0);}/* ---------------------------------------------------------- CountEntriesInFrame -- *//* Count the entries in the given Enigma frame; pass back the number ofvoice 1 and voice 2 entries separately.Returns TRUE if ok, FALSE if frameL is out of range. */static Boolean CountEntriesInFrame(short frameL, short *numV1Entries,												short *numV2Entries){	short	lastEL, thisEL, numV1, numV2;		*numV1Entries = *numV2Entries = 0;	if (frameL<1 || frameL>gNumFrames) return FALSE;		numV1 = numV2 = 0;	lastEL = gETF.pFrames[frameL].lastL;			for (thisEL = gETF.pFrames[frameL].firstL; thisEL; thisEL = gETF.pEntries[thisEL].nextL) {		if (gETF.pEntries[thisEL].inVoice2)			numV2++;		else			numV1++;		if (thisEL==lastEL) break;									/* Don't go to next frame! */	}	*numV1Entries = numV1;	*numV2Entries = numV2;		return TRUE;}/* ----------------------------------------------------------------- GetETFTuplet -- */static Boolean GetETFTuplet(short thisEL, short *tupletID){	register short	i;		for (i = 1; i<=gNumTuplets; i++) {		if (gETF.pTuplets[i].entryL==thisEL) {			*tupletID = i;			return TRUE;		}	}	MayErrMsg("GetETFTuplet: entry %d claims to start a tuplet, but can't find tuplet record for it.", thisEL);	*tupletID = 0;	return FALSE;}/* ----------------------------------------------------------------- GetETFFrameL -- *//* Return the frame that contains notes on the given staff in the given measure in thegiven layer. If there is no such frame (e.g., it's an empty measure), return zero.If there is an error, return NoGood. */static short GetETFFrameL(short staffn, short measn, short layern){	register short	fL, sID;		sID = GetETFStaffID(staffn);	if (sID==NoGood) return (NoGood);		for (fL = 1; fL<=gNumFrames; fL++)		if (gETF.pFrames[fL].staffID==sID &&				gETF.pFrames[fL].meas==measn &&				gETF.pFrames[fL].layerNum==layern)			return (fL);		return (0);}/* ------------------------------------------------------------- GetETFEntryStaff -- *//* Get the staff this ETF entry belongs to (even if it contains a cross-staff note).NB: this is an index into the ETF staff array, not necessarily a staffnum in scoreorder! */static short GetETFEntryStaff(short entryL){	short	frameL;		frameL = gETF.pEntries[entryL].frameL;	return (gETF.pFrames[frameL].staffID);}/* ---------------------------------------------------------------- GetETFStaffID -- *//* Return an index into the ETF staff array for the staff number <staffn> in score order(i.e., from top to bottom of score). Note that the index into the staff array does notnecessarily correspond to score order, because, for example, the top staff in a Finalescore might have been created after the third staff, etc. */static short GetETFStaffID(short staffn){	register short	staffID;								/* NB: index into array of ETF staves, not nec. same as staff number */		for (staffID = 1; staffID<=gNumStaves; staffID++)		/* NB: NOT gNumStavesUsed. (Include unused staves in search.) */		if (gETF.pStaves[staffID].staffNum==staffn)			return (staffID);	return (NoGood);}/* -------------------------------------------------------- GetETFSysRangeForPage -- *//* Given an ETF page number, find the first and last systems that appear on thatpage. If the page is blank (contains no systems), set startSys and endSys to 0.The caller is responsible for deciding what to do about a blank page (which issupported in Finale, but not currently in Nightingale).If there is an error calculating the system range, return FALSE; else return TRUE. */static Boolean GetETFSysRangeForPage(short ETFpg, short *startSys, short *endSys){	short	i, thisStartSys, nextStartSys;		if (ETFpg<1 || ETFpg>gNumPages) goto broken;		thisStartSys = gETF.pPages[ETFpg].startSys;	if (thisStartSys<1) {									/* It's a blank page. */		*startSys = 0;		*endSys = 0;	}	else {		*startSys = thisStartSys;		if (ETFpg==gNumPages)								/* It's the last page in score. */			*endSys = gNumSystems;	// ???NB: make sure that gNumSystems gives correct number of systems in use! 		else {													/* Search for next non-empty page's startSys. */			for (i = ETFpg+1; i<=gNumPages; i++) {				nextStartSys = gETF.pPages[i].startSys;				if (nextStartSys>0) break;			}			if (nextStartSys>0)				*endSys = nextStartSys - 1;			else													/* ETFpg is last non-empty page in score. */				*endSys = gNumSystems;	// ???see caution above!		}	}		return TRUE;broken:	*startSys = *endSys = 0;	return FALSE;}/* ----------------------------------------------------- GetETFMeasRangeForSystem -- *//* Given an ETF system number, find the first and last measures that appear on thatsystem. If there is an error calculating the measure range, return FALSE; else returnTRUE. Assumes that a system contains at least one measure, and that the ETF filecontains sufficient formatting information (i.e., the Finale score has been in pageview before). */static Boolean GetETFMeasRangeForSystem(short ETFsys, short *startMeas, short *endMeas){	short startm, endm;		if (ETFsys<1 || ETFsys>gNumSystems) goto broken;		startm = gETF.pSystems[ETFsys].startMeas;	if (startm<1 || startm>gNumMeas) goto broken;		endm = gETF.pSystems[ETFsys].startMeasNext - 1;#ifdef NOMORE	if (endm<1 || endm>gNumMeas) goto broken;#else	if (endm<1) goto broken;	if (endm>gNumMeas) endm = gNumMeas;			/* ??scores w/ many deleted meas (e.g. "NowYou'reGone, mm. 24-6")																	may have incorrect ^FS records! */#endif	if (startm>endm) goto broken;		*startMeas = startm;	*endMeas = endm;	return TRUE;broken:	*startMeas = *endMeas = 0;	return FALSE;}/* ------------------------------------------------------------------- GetETFClef -- *//* Get the clef affecting this ETF entry.Return an ETF clef type code (not a Nightingale one). (See the eETFclefs enumfor these.) If the search fails, return ETFCLEF_BADCLEF. */static char GetETFClef(short entryL, FASTFLOAT startTime){	char	clefType = ETFCLEF_BADCLEF;	short	i, frameL, clefGrp = 0;		frameL = gETF.pEntries[entryL].frameL;	if (gETF.pFrames[frameL].hasClefChange) {		clefGrp = gETF.pFrames[frameL].startClef;					/* Interpret as pointer to clef records. */		for (i = gNumClefs; i>0; i--)									/* Search backwards through the array of clef */			if (gETF.pClefs[i].clefGroup==clefGrp)					/* records until we find the right clefGroup. */				if (gETF.pClefs[i].startTime<=startTime) {		/* Find the clef with the latest startTime */					clefType = gETF.pClefs[i].clefType;				/* that is earlier than or at <startTime>. */					break;													/* (NB: Within a clefGroup, clefs are in startTime order.) */				}	}	else		clefType = gETF.pFrames[frameL].startClef;				/* Use the frame's startClef. */		return (clefType);}/* ---------------------------------------------------------------- GetETFTimeSig -- *//* Get the time signature affecting this ETF measure. If <staffn> is ANYONE, getthe time sig. from the measure object -- it affects all staves. Else, get thetime sig. affecting only <staffn>.???I don't know where to get this information yet!!!NB: timeSigDenom is in Enigma Durational Units, so must be converted to musicalunits by caller. (As far as I know, Finale doesn't let you create a time sig. changein the *middle* of a measure. You would have to fake this using an invisible measure,so we don't have to worry about it.) */static Boolean GetETFTimeSig(short measL, short staffn, short *timeSigNum, short *timeSigDenom){	short	sID;		if (staffn==ANYONE) {		*timeSigNum = gETF.pMeasures[measL].timeSigNum;		*timeSigDenom = gETF.pMeasures[measL].timeSigDenom;	}	else {		sID = GetETFStaffID(staffn);		if (sID==NoGood) return FALSE;		// ???etc...?		*timeSigNum = 4;		*timeSigDenom = 1024;	}	return TRUE;}/* ----------------------------------------------------------------- GetETFKeySig -- *//* Get the ETF key sig. on staff number <staffn> at the beginning of measure <measL>,taking into account the transpose setting for that staff. (For example, if astaff is set up to notate Bb clarinet, it will have a key sig. of D major whenthe piece is in C major -- its notes will sound a whole step lower than written.The staff's keyAlter field gives the number of accidentals to add or subtract fromthe main key sig. given by the measure object.???Let's hope that factoring in keyAlter doesn't create a non-sensical key sig!Should do some better error checking and recovery. *???Later, should support a change of key sig. affecting *only* this staff and not others.That information would be somewhere other than the measure object, but I don't yet knowhow Finale stores it.(As far as I know, Finale doesn't let you create a key sig. change in the *middle* ofa measure. You would have to fake this using an invisible measure, so we don't haveto worry about it.)NB: this returns an ETF key sig. code, not a Nightingale one. To get theNightingale sharpsOrFlats value for a key sig., use ETFtoNightKeysig. */static Boolean GetETFKeySig(short measL, short staffn, short *keySig){	short	sID, ks, relMinor;	char	ksLoByte;		if (measL<1 || measL>gNumMeas) goto broken;	ks = gETF.pMeasures[measL].keySig;		if (staffn<1 || staffn>gNumStavesUsed) goto broken;	sID = GetETFStaffID(staffn);	if (sID<1 || sID>gNumStaves) goto broken;	ksLoByte = (char) (ks & 0x00FF);	relMinor = ks & 0x0100;						/* Tells us what the tonic for this key sig is:															major or its relative minor. Don't care now. */	/* Factor in transpose key setting for this staff. Now we have the keysig 	 * expressed in circle of 5ths order, from 7 to -7 (CMaj=0).	 */	ksLoByte += gETF.pStaves[sID].keyAlter;// ???if (ksLoByte>7 || ksLoByte<-7) then what?	ks = relMinor + (Byte)ksLoByte;	*keySig = ks;	return TRUE;broken:	*keySig = 0;	return FALSE;}/* ---------------------------------------------------------- GetETFRaiseLowerAcc -- *//* Given an index into the ETF note array, return the number of semitones toraise or lower that note's diatonic pitch using accidentals.(Presumably, these increments could be quartertones instead of semitonesunder some Finale configuration...) */static char GetETFRaiseLowerAcc(short noteL){	char	raiseLower, ETFaccidental;		ETFaccidental = gETF.pNotes[noteL].accidental;	raiseLower = ETFaccidental & 0x07;						/* uses bits 0-2 */	if (ETFaccidental & 0x08)									/* if bit 3 set, lower rather than raise */		raiseLower = -raiseLower;	return (raiseLower);}static char keyHalflnOffsets[15][2] = {	{7,	7},	/* C# major or A# minor */	{6,	3},	/* F# major or D# minor */	{5,	6},	/* B major or G# minor */	{4,	2},	/* E major or C# minor */	{3,	5},	/* A major or F# minor */	{2,	1},	/* D major or B minor */	{1,	4},	/* G major or E minor */	{0,	0},	/* C major or A minor */	{-1,	3},	/* F major or D minor */	{-2,	6},	/* Bb major or G minor */	{-3,	2},	/* Eb major or C minor */	{-4,	5},	/* Ab major or F minor */	{-5,	1},	/* Db major or Bb minor */	{-6,	4},	/* Gb major or Eb minor */	{-7,	7}		/* Cb major or Ab minor */};/* ---------------------------------------------------------- GetETFAbsoluteHalfLn -- *//* Half-line position in an Enigma file is relative to the transpose setting for the staffand to the keysig for the measure the note is in. Finale uses zero for the tonic of akey (starting from mid-C up). For example, middle C is zero in the key of C major, but-2 in the key of E major (in which E above middle C is zero). When a staff has a transposesetting (e.g., for a Bb clarinet), the half-line value of a written note is the half-line valueits sounding pitch would have if the staff had no transpose setting. For example, when a Bbclarinet reads middle C, it plays Bb a whole step below; in this case, written middle C hasthe same half-line value that Bb would have in a non-transposing staff: -1.(Note that this half-line value is independent of the particular clef in use. It is *not* relative to the top of the staff.)Nightingale uses two types of half-line value: middle-C-relative and staff-relative.Unlike in Finale, neither type is affected by the current keysig and transpose setting.For both types, the half-line value falls as the pitch rises, which is opposite from Finale.A SYNC subobject's yqpit is relative to middle C (which is zero), regardless of theclef context. However, the half-line value passed to SetupNote is relative to the topof the staff, not to middle C.GetETFAbsoluteHalfLn converts Enigma's relative half-line value to an absolute value, which isnot relative to the keysig and transpose settings, but is still relative to middle C.For example, GetETFAbsoluteHalfLn returns middle C (natural, sharp or flat) as having ahalf-line value of zero, regardless of the key sig or transpose setting in effect.NB: this value is not a valid Nightingale middle-C-relative halfLn value, because itrises, rather than falls, as the pitch rises.???for later... Finale lets you have an independent keysig in a frame...            ... Also lets you have non-standard keysigs. How does this affect halfln????All this code assumes that the ETF file uses standard keysigs! */static char GetETFAbsoluteHalfLn(short entryL,											short noteL)			/* index into note array (gETF.pNotes) */{	register short	i;	short				measL, frameL, ks, sID, relMinor;	char				trans, ksLoByte, hloffset, relHalfLn;		frameL = gETF.pEntries[entryL].frameL;	measL = gETF.pFrames[frameL].meas;	sID = gETF.pFrames[frameL].staffID;		/* NB: Don't use GetETFKeySig, because that already factors in keyAlter, and	 * I think that might screw us up here!	 */	ks = gETF.pMeasures[measL].keySig;		/* Decode keysig short:	 * low byte encodes keysigs in circle of 5ths order, from 7 to -7 (CMaj=0);	 * if 8th bit is set, use relative minor key (i.e., subtract 2 from half-line).	 */	ksLoByte = (char) (ks & 0x00FF);	relMinor = ks & 0x0100;		/* find transpose setting (half-line offset btw. written and sounding pitch) */	trans = gETF.pStaves[sID].transpInterval;// ???NB: the halfline val might also be affected by the transpose clef!!! How?	relHalfLn = gETF.pNotes[noteL].halfline;		for (i = 0; i<15; i++) {		if (keyHalflnOffsets[i][0]==ksLoByte) {			hloffset = keyHalflnOffsets[i][1];			if (relMinor) hloffset -= 2;			hloffset %= 7;										/* Put notes in C# and Cb major in same octave as in C major. */			if (hloffset<0) hloffset += 7;				/* Now notes in A, B and Bb minor, whose hloffset<0, are 8ve too low. (NB: mod of negative) */			return (relHalfLn + hloffset + trans);		}	}	return (relHalfLn);										/* Shouldn't happen! */}/* ---------------------------------------------------------------- GetETFRastral -- *//* Given the reduction/enlargement percent for a page, a system and a staff in Finale (edited with the % tool), return a Nightingale staff size rastral.This Nightingale staff size will be approximately the same height as theFinale staff.For example, if the Finale page size is 75%, system size is 100% and staffsize is 75%, the resulting staff size is 56.25% of normal. The closestapproximation to this size in Nightingale is rastral 7. */static short GetETFRastral(short pgSzPct, short sysSzPct, short stfSzPct){	float	szPct;		szPct = (float)pgSzPct * (((float)sysSzPct * ((float)stfSzPct / 100.)) / 100.);		/* Select a rastral that is approximately the same size as the Finale staff.	 * ??Bias towards the rastrals that provide equal space btw. staff lines : 1, 2, 5, 7.	 */	if (szPct<48.)		return (8);	if (szPct<56.)		return (7);		/* 50% == rastral 7 */	if (szPct<64.)		return (6);	if (szPct<72.)		return (5);	if (szPct<80.)		return (4);		/* 75% == rastral 4 */	if (szPct<88.)		return (3);	if (szPct<96.)		return (2);	if (szPct<104.)	return (1);		/* 100% == rastral 1 */	else					return (0);		/* user-configurable rastral, default = 28pts??? */}/* --------------------------------------------------------------------------------- *//* ETF conversion utility functions *//* ---------------------------------------------------------------- ETF2NightClef -- *//* A Finale doc can use any of 8 different kinds of clef. The standard ones arelisted below. But in Finale you can customize any of the 8. I'm assumingfor now that none of the standard 8 have been customized. */static short ETF2NightClef(short ETFClef){	short	nightClef;		switch (ETFClef) {		case ETFCLEF_TREB:		nightClef = TREBLE_CLEF;		break;		case ETFCLEF_ALTO:		nightClef = ALTO_CLEF;			break;		case ETFCLEF_TENOR:		nightClef = TENOR_CLEF;			break;		case ETFCLEF_BASS:		nightClef = BASS_CLEF;			break;		case ETFCLEF_PERC:		nightClef = PERC_CLEF;			break;		case ETFCLEF_TREB8VB:	nightClef = TRTENOR_CLEF;		break;		case ETFCLEF_BASS8VB:	nightClef = BASS8B_CLEF;		break;		case ETFCLEF_BARI:		nightClef = BARITONE_CLEF;		break;//		case ETFCLEF_TREB8VA:	nightClef = TREBLE8_CLEF;		break;		default:						nightClef = -1;	}		return (nightClef);}/* ---------------------------------------------------------------- Night2ETFClef -- */static short Night2ETFClef(short nightClef){	short	ETFClef;		switch (nightClef) {		case TREBLE_CLEF:			ETFClef = ETFCLEF_TREB;			break;		case ALTO_CLEF:			ETFClef = ETFCLEF_ALTO;			break;		case TENOR_CLEF:			ETFClef = ETFCLEF_TENOR;		break;		case BASS_CLEF:			ETFClef = ETFCLEF_BASS;			break;		case PERC_CLEF:			ETFClef = ETFCLEF_PERC;			break;		case TRTENOR_CLEF:		ETFClef = ETFCLEF_TREB8VB;		break;		case BASS8B_CLEF:			ETFClef = ETFCLEF_BASS8VB;		break;		case BARITONE_CLEF:		ETFClef = ETFCLEF_BARI;			break;//		case TREBLE8_CLEF:		ETFClef = ETFCLEF_TREB8VA;		break;		default:						ETFClef = -1;	}	return (ETFClef);}/* ------------------------------------------------------------- ETF2NightTimeSig -- *//* Convert an ETF time signature to Nightingale format. Specifically, convert theETF denominator (in Enigma Durational Units) to the musical kind. Determinewhether the time signature is compound (e.g., 6/8 with 2 dotted quarter beats)or simple (e.g., 6/8 with 6 8th note beats), and compute the numerator accordingly. (NB: the distinction between the two kinds of 6/8, for example,is not important in Nightingale.)  If both the ETF numerator and denominator are zero, set the Nightingale numerator and denominator to 4 (assuming that 4/4 is a Finale default). Returns TRUE if conversion was successful, FALSE if not. */static Boolean ETF2NightTimeSig(short ETFnum, short ETFdenom, short *nightNum, short *nightDenom, Boolean *isCompound){	switch (ETFdenom) {						/* oversimplified conversion of ticks to CMN duration (see TSDENOM_BAD) */		case 4096:	*nightDenom = 1;		*isCompound = FALSE;		break;		case 6144:	*nightDenom = 2;		*isCompound = TRUE;		break;		case 2048:	*nightDenom = 2;		*isCompound = FALSE;		break;		case 3072:	*nightDenom = 4;		*isCompound = TRUE;		break;		case 1024:	*nightDenom = 4;		*isCompound = FALSE;		break;		case 1536:	*nightDenom = 8;		*isCompound = TRUE;		break;		case 512:	*nightDenom = 8;		*isCompound = FALSE;		break;		case 768:	*nightDenom = 16;		*isCompound = TRUE;		break;		case 256:	*nightDenom = 16;		*isCompound = FALSE;		break;		case 384:	*nightDenom = 32;		*isCompound = TRUE;		break;		case 128:	*nightDenom = 32;		*isCompound = FALSE;		break;		case 192:	*nightDenom = 64;		*isCompound = TRUE;		break;		case 64:		*nightDenom = 64;		*isCompound = FALSE;		break;		case 0:		*nightDenom = 4;		*isCompound = FALSE;		break;				default:		goto broken;	}	if (ETFnum==0)		*nightNum = 4;	else {		if (*isCompound==TRUE)			*nightNum = ETFnum * 3;		else			*nightNum = ETFnum;	}	return TRUE;broken:	*nightNum = *nightDenom = 0;	*isCompound = FALSE;	return FALSE;}/* Ngale logical to Enigma logical (in EDU's) dur. lookup table *//* CAUTION: This will be messed up if MAX_L_DUR is ever changed. */static short l2edu_durs[MAX_L_DUR+1] = {	-99,			/* (empty) */	8192,			/* breve (8192 Enigma Duration Units) */	4096,			/* whole */	2048,			/* half */	1024,			/* quarter */	512,			/* eighth */	256,			/* 16th */	128,			/* 32nd */	64,			/* 64th */	32				/* 128th */};/* ----------------------------------------------------------------- ETF2NightDur -- *//* Convert an Enigma logical duration expressed in EDU's (Enigma Duration Units)<EDUdur> to a more-or-less equivalent Nightingale note l_dur code and numberof augmentation dots. If there are any remainder EDU's, return them, elsereturn zero. The remainder is always POSITIVE, i.e., we may return a durationthat's shorter than desired but never longer. If <EDUdur> is either shorterthan the shortest, or longer than the longest, Nightingale logical duration,return -1. (ETF2NightDur was adapted from LDur2Code in "SpaceTime.c".)NB: Tuplets are handled at a higher level and are irrelevant here. */static short ETF2NightDur(short EDUdur, short *pLDur, short *pNdots){	short	i, j, remainder,			maxDots;								/* 128th can't have dots, 64th can have 1 dot, 32nd can have 2, etc. */	for (i = MAX_L_DUR, maxDots = 0; i>UNKNOWN_L_DUR; i--, maxDots++) {		if (l2edu_durs[i]==EDUdur) {						/* We have an exact match; no dots are necessary. */			*pLDur = i;			*pNdots = 0;			return 0;											/* No remainder */		}		else if (l2edu_durs[i]>EDUdur) {			/* l2edu_durs[i+1] is the longest undotted duration shorter than <EDUdur>.			 *	See if adding dots can match <EDUdur> closely enough.			 */			if (i==MAX_L_DUR) return (-1);				/* No, dur. shorter than shortest possible */			*pLDur = i+1;			remainder = EDUdur - l2edu_durs[i+1];						*pNdots = 0;			for (j = i+2; j<=MAX_L_DUR; j++) {				if (remainder>=l2edu_durs[j] && *pNdots<maxDots) {					(*pNdots)++;					remainder -= l2edu_durs[j];				}				else					return remainder;							/* We've gotten as close as we can. */			}		}	}		return (-1);		/* The duration is longer than the longest possible single note/rest with dots. */}/* -------------------------------------------------------------- ETF2NightHalfLn -- *//* Convert an ETF half-line into a Nightingale halfline. First take account of thekeysig and context and transpose setting for this staff by calling GetETFAbsoluteHalfLn.Then convert to one of two types of half-line used by Nightingale functions, dependingon <type>. If <type> is STAFF_REL_HALFLN, use the current clef context to delivera half-line value that is relative to the top line of the staff, which is zero,regardless of which clef is used. If <type> is MIDDLEC_REL_HALFLN, do nothing tothe ETF absolute half-line. Finally, for both types, invert the value so that itrises as pitch falls. (This is opposite of Finale.)NB: This assumes that the effective clef for a note will be the same in the ETF file andthe Nightingale doc! */static char ETF2NightHalfLn(short thisEL, short thisNL, FASTFLOAT startTime, short type){	char	ngHalfLn, absETFhalfLn, clefType, hloffset=0;		absETFhalfLn = GetETFAbsoluteHalfLn(thisEL, thisNL);	if (type==MIDDLEC_REL_HALFLN)		hloffset = 0;	else {									/* type==STAFF_REL_HALFLN */		clefType = GetETFClef(thisEL, startTime);		switch (clefType) {			case ETFCLEF_TREB:		hloffset = 10;		break;			case ETFCLEF_ALTO:		hloffset = 4;		break;			case ETFCLEF_TENOR:		hloffset = 2;		break;			case ETFCLEF_BASS:		hloffset = -2;		break;			case ETFCLEF_PERC:		hloffset = 10;		break;		/* same as treb */			case ETFCLEF_TREB8VB:	hloffset = 3;		break;			case ETFCLEF_BASS8VB:	hloffset = -9;		break;			case ETFCLEF_BARI:		hloffset = 0;		break;	// ???fix up this		}// 								in Ngale		in Finale// trebclef:	top line			0				10//             mid C				10				0  // 				high G			-1				11//             mid G				6				4  // bassclef:	top line			0				-2// 				mid C				-2				0// 				D below			4				-6	}		ngHalfLn = -absETFhalfLn;	ngHalfLn += hloffset;		return (ngHalfLn);}/* ------------------------------------------------------------- ETFtoNightKeysig -- *//* Delivers the <sharpsOrflats> parameter used in many Nightingale keysig functions.Disregards the high byte of <ETFkeysig>, which tells whether the keysig is fora major key or its relative minor. */static char ETFtoNightKeysig(short ETFkeysig){	return ((char) (ETFkeysig & 0x00FF));}/* --------------------------------------------------------------- ValidETFTuplet -- *//* Check whether this ETF tuplet is valid, and whether Nightingale can handle it. Returns TRUE if it is, FALSE if it's not. */static Boolean ValidETFTuplet(short tupletID){	PETF_TUPLET	p;	short			nInTuple, lDur, ndots, remainder;		p = &gETF.pTuplets[tupletID];	if (p->entryL<1 || p->entryL>gNumEntries) return FALSE;	if (p->accNum>MAX_TUPLENUM || p->accDenom>MAX_TUPLENUM) return FALSE;	if (p->numDurUnit!=p->denomDurUnit) return FALSE;		// ???don't think Ng can handle this		remainder = ETF2NightDur(p->numDurUnit, &lDur, &ndots);	if (remainder || ndots!=0) return FALSE;	nInTuple = CountETFTupletEntries(tupletID);	if (nInTuple<2) return FALSE;	return TRUE;}/* --------------------------------------------------------------- DisplayNightDS -- */static void DisplayNightDS(Document *doc,						  Boolean check,					/* Check as well as display? */						  Boolean showLinks,				/* Show node addr., links, size? */						  Boolean showSubs)				/* Show subobjects? */{	#ifndef PUBLIC_VERSION	LINK	pL;	int	count;	DebugPrintf("DISPLAY DS:\n");	for (pL = doc->headL, count = 1; pL; pL = RightLINK(pL), count++) {		DisplayNode(doc, pL, count, showLinks, showSubs, FALSE);		if (check) {			DCheckNode(doc, pL, MAIN_DSTR, FALSE/*fullcheck?*/);			DCheckNodeSel(doc, pL);		}	}#endif}/* --------------------------------------------------------------------------------- *//* Functions that call Macintosh Toolbox routines. *//* ---------------------------------------------------- BuildConvertedETFFileName -- */static void BuildConvertedETFFileName(Str255 fn, Str255 newfn){	unsigned char	str[64];	unsigned char	*p;	long				len;	Pstrcpy(newfn, fn);	/* Remove ".etf" suffix, if any. */	len = *(unsigned char *)newfn;	p = &newfn[len-3];	if (!strncmp((char *)p, ".etf", (size_t)4) || !strncmp((char *)p, ".ETF", (size_t)4))		newfn[0] = len-4;	/* Append " (converted)" to its name. */	GetIndString(str, MiscStringsID, 5);	PStrCat(newfn, str);}enum {	FLOWIN_LYRICS=1,	DISCARD_LYRICS,	SAVE_LYRICS};/* ------------------------------------------------------------------- SaveLyrics -- *//* If the Enigma file has any lyrics, ask the user what they want to do with them.   The choices are:     1) save them in a text file,     2) place them in the Flow In Text/Lyrics dialog, or     3) discard them.   NB: This function ALWAYS returns TRUE right now.*/static Boolean SaveLyrics(Str255 fileName)		/* name of ETF file, not Ngale score name */{	short		itemHit;	Boolean	ok;	Str255	suggestName;	unsigned char	str[64];	unsigned char	*p;	long		len;		if (!gETF.pLyrics[0].pText) return TRUE;				/* No lyrics, so no need to present alert. */		/* Ask what user wants to do with the lyrics. */	PlaceAlert(SAVEETFLYRICS_ALRT, NULL, 0, 80);	ArrowCursor();	itemHit = CautionAlert(SAVEETFLYRICS_ALRT, NULL);		switch (itemHit) {		case DISCARD_LYRICS:			break;		case FLOWIN_LYRICS:			ok = SetFlowInText((Ptr)gETF.pLyrics[0].pText);			break;		case SAVE_LYRICS:			/* Construct a suggested file name from the ETF file name. */			Pstrcpy(suggestName, fileName);						/* Remove ".etf" suffix, if any. */			len = *(unsigned char *)suggestName;			p = &suggestName[len-3];			if (!strncmp((char *)p, ".etf", (size_t) 4) || !strncmp((char *)p, ".ETF", (size_t) 4))				suggestName[0] = len-4;					/* Append " (lyrics)" to its name. */			GetIndString(str, ENIGMA_STRS, 4);			PStrCat(suggestName, str);						ok = SaveTextToFile((Ptr)gETF.pLyrics[0].pText, suggestName, 0);			break;	}	return TRUE;}#endif /* !LIGHT_VERSION */