/* Enigma.h	for NightingaleDefinitions and prototypes for routines that read and convert EnigmaTransportable Format files to Nightingale format. Written by John Gibson. *//*											NOTICE * * THIS FILE IS PART OF THE NIGHTINGALEª PROGRAM AND IS CONFIDENTIAL PROP- * ERTY OF ADVANCED MUSIC NOTATION SYSTEMS, INC.  IT IS CONSIDERED A TRADE * SECRET AND IS NOT TO BE DIVULGED OR USED BY PARTIES WHO HAVE NOT RECEIVED * WRITTEN AUTHORIZATION FROM THE OWNER. * * Copyright © 1986-97 by Advanced Music Notation Systems, Inc. All Rights Reserved. */#define DOAUTOBEAM				1#define LISTOBJECTS				1#define CNTLKEYFORLISTOBJECTS	1#define LISTSCORE					0		// ??Code for this isn't very recent, and may be wrong by now!#define CONVERTSCORE				1#define SHORTDEBUG				0#define FULLDEBUG					0#define SHOW_PROGRESSWINDOW	1#define NoGood -1/* ----------------------------------------------------------------------------------- *//* Prototypes of functions shared between "EnigmaConvert.c" and "EnigmaParse.c", but nototherwise public. *//* in "EnigmaConvert.c"... *//* (none as of yet) *//* in "EnigmaParse.c"... */Boolean ParseETFFile(Str255 ETFfileName);void DisposETFMemory(void);/* ----------------------------------------------------------------------------------- *//* Conversion macros *//* Given a measurement in EVPU's (aka 1/4 points) and a Nightingale staff height inDDIST's, return in DDIST's the EVPU value scaled to the staff height. In Finale, EVPU'sare 1/4 points only when the staff height is 24 points. (That's the staff size you seein Scroll View, and is the staff size used in Page View when there are no Reduce/Enlargepercentages in effect. See comments at GetETFRastral.) Get <stfHt> fromcontext.staffHeight. */#define evpu2d(evpu, stfHt)	(((long)((evpu)<<2)*(stfHt))/pt2d(24))/* Other macros */#define BADUSERVOICENUM(uVoice) ((uVoice)<1 && (uVoice)>31)		/* bcs VOICEINFO's relVoice is a 5-bit field *//* ----------------------------------------------------------------------------------- *//* Typedefs for creating temporary Enigma data structure */typedef unsigned INT16 ELINK;		/* ???size of index into an array of Enigma objects */typedef struct {					/* from ^FR, ^GF and ^LL codes */	short		staffID;				/* CAREFUL: this is staff ID, not nec. staff num in score order! */	short		layerInfoID;		/* For use only by parsing functions (ParseLL, PostProcessETF) */	short		meas;	short		firstL;				/* index into entry pool of frame's first note/rest */	short		lastL;				/* index into entry pool of frame's last note/rest */	short		measWid;	short		startClef;			/* Clef id if this frame has only one clef, i.e., if hasClefChange is										 * FALSE. (See eETFclefs enum.) If hasClefChange, then startClef is an										 * index into a collection of clef changes ("clefGroup") occuring in this frame. */	char		hasClefChange;		/* contains one or more mid-measure clef changes (^CE records) */	char		layerNum;			/* 1 through 4 */} ETF_FRAME, *PETF_FRAME;typedef struct {					/* from ^MS code */	short		measWid;	short		keySig;	short		timeSigNum;	short		timeSigDenom;} ETF_MEAS, *PETF_MEAS;typedef struct {					/* from ^IU and ^IS codes */	short		vOffset;	short		timeSigNum;			/* cf MEASURE */	short		timeSigDenom;	short		staffNum;			/* position in score, from top to bottom (e.g., fl==1, ob==2, cl==3, etc.) */#ifdef NOTYET	short		sizePct;#endif	char		group;	char		startClef;	char		transpClef;	char		keyAlter;			/* see Staff Transposition dlog */	char		transpInterval;	/* ditto */	char		numLines;			/* number of staff lines */	char		v1NgIvoices[4];	/* Ngale internal voice numbers used by V1 of layers 0-3 */	char		v2NgIvoices[4];	/* Ngale internal voice numbers used by V2 of layers 0-3 */	char		fullname[26];		/* Finale limits to 24 chars */	char		abrevname[26];		/* Finale limits to 24 chars */} ETF_STAFF, *PETF_STAFF;typedef struct {	short		systemNum;	short		staffID;#ifdef NOTYET	short		vOffset;	char		group;	char		filler;#endif} ETF_OPTIMIZEDSTAFF, *PETF_OPTIMIZEDSTAFF;typedef struct {					/* from ^FS code */	short		startMeas;	short		startMeasNext;#ifdef NOTYET	short		sizePct;#endif} ETF_SYSTEM, *PETF_SYSTEM;typedef struct {					/* from ^PO and ^PS codes */	short		height;	short		width;	short		startSys;	short		sizePct;	Rect		margins;} ETF_PAGE, *PETF_PAGE;typedef struct {					/* from ^eE code, representing a note/chord/rest in one voice */	short		prevL;				/* link to previous ENTRY */	short		nextL;				/* link to next ENTRY */	short		firstNoteL;			/* link to first NOTE */	short		frameL;				/* link to frame containing this entry */	short		xOffset;				/* "position" in frame dlog; range of signed short (in EVPU's) */	short		dur;					/* logical (I hope!) duration in EDU's */	char		numNotes;			/* number of NOTE's in this ENTRY */	Boolean	validNode:1;		/* if FALSE, no entry in this array slot */	Boolean	legality:1;	Boolean	visible:1;	Boolean	isGrace:1;	Boolean	isRest:1;	Boolean	launchesVoice2:1;	Boolean	inVoice2:1;	Boolean	startTuplet:1;	Boolean	hasPerfData:1;	Boolean	notBeamedFromPrev:1;	Boolean	secBeamBreak:1;	Boolean	hasBeamExtension:1;	Boolean	hasCrossStem:1;	Boolean	freezeStem:1;	Boolean	stemFrozenUp:1;	Boolean	flipTie:1;	Boolean	hasChordSym:1;	Boolean	hasArticMark:1;	char		filler:6;} ETF_ENTRY, *PETF_ENTRY;typedef struct {					/* from ^eE code, representing a single note (within a chord) or rest */	short		entryL;	short		nextL;	char		halfline;	char		accidental;			/* how many semitones to raise this diatonic pitch (range: 1-15, just 4 bits) */	Boolean	hasAcc:1;	Boolean	tiedR:1;	Boolean	tiedL:1;	Boolean	crossStaff:1;	char		filler1:4;	char		filler2;} ETF_NOTE, *PETF_NOTE;typedef struct {					/* from ^TP and ^TN codes */	short		entryL;				/* link to first entry in tuplet */	char		accNum;	char		accDenom;	short		numDurUnit;			/* in EDU's */	short		denomDurUnit;		/* in EDU's (NB: no such thing in NG, which assumes numDurUnit==denomDurUnit?)*/	char		format;				/* see eETFtuplets enum below */	char		filler:7;	Boolean	useRatio:1;} ETF_TUPLET, *PETF_TUPLET;typedef struct {	short		clefGroup;			/* Clefs in same frame have same clefGroup. NOTE: clefGroup not nec. == frameL! */	short		frameL;				/* frame that owns this clef */	short		startTime;			/* in EDU's from start of meas */	short		vOffset;				/* vertical offset from top of staff */	short		sizePct;				/* Percent of normal clef size. Default: 75; range: 1-32767! */	char		clefType;			/* see eETFclefs enum below */	char		filler;} ETF_CLEF, *PETF_CLEF;typedef struct {	char		group;	char		type;					/* See eETFconnects enum. */	short		xOffset;				/* from left edge of staff */#ifdef NOTYET	short		vAdjustTop;	short		vAdjustBot;#endif	} ETF_CONNECT, *PETF_CONNECT;#ifdef NOTYETtypedef struct {	Byte	*pText;					/* Points to a block of text for this text block (NOT null terminated). */										/* Allocated by ParseTextBlocks, disposed by DisposETFMemory. */} ETF_TEXTBLOCK, *PETF_TEXTBLOCK;#endiftypedef struct {#ifdef NOTYET	short	verseNum;	// ??can just use array index?#endif	Byte	*pText;					/* Points to a block of text for this verse (NOT null terminated). */										/* Allocated by ParseLyrics, disposed by DisposETFMemory. */} ETF_LYRIC, *PETF_LYRIC;typedef struct {	PETF_FRAME				pFrames;	PETF_MEAS				pMeasures;	PETF_STAFF				pStaves;	PETF_SYSTEM				pSystems;	PETF_OPTIMIZEDSTAFF	pOptimizedStaves;	PETF_PAGE				pPages;	PETF_ENTRY				pEntries;	PETF_NOTE				pNotes;	PETF_TUPLET				pTuplets;	PETF_CLEF				pClefs;	PETF_CONNECT			pConnects;#ifdef NOTYET	PETF_TEXTBLOCK			pTextBlocks;#endif	PETF_LYRIC				pLyrics;} ETF;/* For temporary array of ^GF records, allocated in AllocETFMemory and disposed in DisposTmpMemory. */typedef struct {	short		staffID;		short		meas;	short		frame;	short		layerInfoID;	short		startClef;	char		hasClefChange;	char		filler;} TMPGFREC, *PTMPGFREC;typedef struct {						/* for use when calling CheckTuplet */	short		nInTuple;	short		tupleNum;	short		tupleDenom;	Boolean	tupletInProgress;} ETFTUPLEPARAM;enum {	ETFTUPLET_NOTHING=0,				/* show nothing */	ETFTUPLET_NUMONLY,				/* show number(s) only (no bracket) */	ETFTUPLET_NUMSLUR,				/* show number(s) with slur */	ETFTUPLET_NUMBRACKET,			/* show number(s) with bracket */	ETFTUPLET_IGNOREFMT=256,	ETFTUPLET_BREAKBRACK=512,	ETFTUPLET_USERATIO=1024,		/* i.e., show ':' */	ETFTUPLET_USEBOTNOTE=2048} /* eETFtuplets */;enum {									/* Enigma clef id's */	ETFCLEF_BADCLEF=-1,	ETFCLEF_TREB,	ETFCLEF_ALTO,	ETFCLEF_TENOR,	ETFCLEF_BASS,	ETFCLEF_PERC,	ETFCLEF_TREB8VB,	ETFCLEF_BASS8VB,	ETFCLEF_BARI} /* eETFclefs */;enum {									/* Enigma connect types */	ETFCONNECT_STRAIGHT=1,			/* thick bar with no curved bracket ends (thicker than Ngale's CONNECTLINE) */	ETFCONNECT_SMALLBRACKET,		/* bracket with less extravagant curved bracket ends than normal bracket */	ETFCONNECT_CURLY,					/* normal curly brace, same as CONNECTCURLY in Ngale */	ETFCONNECT_BRACKET=6				/* normal bracket, same as CONNECTBRACKET in Ngale */} /* eETFconnects */;